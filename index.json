[{"content":"车道线检测方浩AAAI2021新SOTA-RESA分享总结\n车道线检测LaneDetection 车道线检测是自动驾驶领域里环境感知环节重要的一部分，之前在商汤实习有接触到项目中的轻量级车道线检测是使用Gridding方法，但没有全面了解过车道线检测，借此次干货分享学习一下~\n1.Background 车道线检测顾名思义如图中所示 检测并预测补全所输入的RGB图像中的K条车道线，每条车道线互相独立类别不同。 上图所示为自动驾驶的实现思路，我们首先通过各种不同的sensors获取周围环境的数据(RGB或RGBD图像，三维点云等)，再使用环境感知算法分析数据，得到感知定位结果并送入Planning规划环节。在Planning环节中通过对感知的环境结果进行分析，做出行为路线等规划，做出决策，车辆控制单元接收到决策，从硬件上操控车辆实现各种驾驶操作。\n车道线检测作为环境感知中非常重要的一部分，对于车辆驾驶决策有以下几点作用：\n 判断当前车辆所在车道，并保持车辆在车道内行驶防止偏向变道。 变道时判断变道行驶角度，并决定何时变道结束。 判断其他车辆所在车道，并预测其他车辆驾驶可能驾驶轨迹。  车道线检测的定义：\n输出有多种形式，根据不同方法有不同输出，可以为instances的mask，我直接输出检测出的mask，也可以为一些点，将这些点连为直线或曲线便为车道线，也可为一些参数，通过这些参数拟合曲线。\n车道线检测主要的难点：\n 遮挡严重，线为一段一段的而我们需要补全，同时可能路面有磨损 有些地方车道线看不清 线又细又长，不想目标检测 语义分割，我们有大块物体可供检测分割，车道线是细长的，在图像中比例不大。 实时性，因为我们需要在自动驾驶中使用，所以需要实时性。  2.Related Work 车道线检测的工作主要有下面几个方向：\n Traditional methods Semantic / instance segmentation-based New formulation (gridding, polynomial, anchor-based, etc.)  传统方法，语义/实例分割方法以及一些比较新奇的思路。传统方法实用性较差，目前大部分方向都集中于第2、3类。 97年的传统方法，首先将RGB转为灰度图，再做高斯模糊，然后用Canny算子检测边缘部分，霍夫变换检测出图像中的直线。所得到的直线并不知道直线的起点与终点所以就如图所示两条直线，所适用场景比较局限。\n两个分支，一个学习pixel embedding一个学习mask，将预测出的线的位置乘以embedding，再用聚类分出来不同的线。此方法思路比较简单，但依赖于聚类，也同样不知道车道线起始与终点，效果并不是很好。\n基于语义分割的很直接的方法，K条线则为K个类别，每条线对应一个类别，最终输出一张含有多个类别的mask，则输出了多条线。本篇工作还用了类似RNN方法，把信息在H与W维度上进行传递。\n后续好多基于分割的方法都致力于将模型轻量化，如上图，第一个方法使用蒸馏，第二个方法使用NAS。 下面这种方法就是Gridding，将图像分成多个小块，我个人理解就是将图像进行下采样，通过各种方式预测出来的grids作为点，最后连接成为车道线。还有其他等等新奇的方法……\n3.RESA 论文地址：RESA\nIntuation： 作者一开始的想法跟我一样\u0026hellip;.：车道线检测看起来就是语义分割，那么我们直接用语义分割当中的算法训练不就可以了吗？作者进行了实验(deeplab)发现语义分割算法得到效果很差，于是有了以下分析：\nWhy classical segmantic segmentation does not work?\n Severe occlusion \u0026amp; ambiguous lanes Sparse supervisory signals inherent in lane annotations (thin and long)  主要来说就是车道线这种特殊case的特殊性：跟语义分割不同，车道线所占区域很窄很小，就如同语义分割中电线杆类别，很容易误检错检，与此同时语义分割是所见即所得，但是车道线因为有虚线所以还需要算法进行自动补全，这是语义分割算法所缺失的 (本次分享及作者的论文其实感觉主要就是解决这个问题的，但是感觉他的特征传递方法work的原因并不是作者想的那样)。\nsturcture: 主要的思想如上图，把特征图进行切片，再以一定步长横向(W维度)纵向(H维度)进行特征的传递，其实这种思路已经很常见了，在3D检测与语义分割中都有人使用过，在车道线检测中SCNN也是这种思路。\n网络结构如上图，很简单，总体就是分割当中的Encoder-\u0026gt;head-\u0026gt;Decoder。\n Encoder就是普通的特征提取网络，VGG ResNet等，根据不同需要 是想实时性还是精确度酌情选择backbone Head中就为作者提出的RESA模块，在横向与纵向上进行传递，细讲就是首先对特征在横向及纵向上进行切片，对于切片后的每一片特征都用1x1卷积进行变换，然后以一定步长加到后面的特征上，很简单。如下图就是从右向左传递。   ​\n上采样部分作者没有采用简单的插值上采样 而是添加了一个反卷积分支，以此来继续修正结果：  Results: 结果部分比较常规，提分感觉并不是很高，而且速度上也并不是特别快\u0026hellip;.（消融实验我就不贴了）\n后续有机会继续看一下车道线检测\n","permalink":"https://cynicsss.github.io/posts/%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8Blanedetection/","summary":"车道线检测方浩AAAI2021新SOTA-RESA分享总结\n车道线检测LaneDetection 车道线检测是自动驾驶领域里环境感知环节重要的一部分，之前在商汤实习有接触到项目中的轻量级车道线检测是使用Gridding方法，但没有全面了解过车道线检测，借此次干货分享学习一下~\n1.Background 车道线检测顾名思义如图中所示 检测并预测补全所输入的RGB图像中的K条车道线，每条车道线互相独立类别不同。 上图所示为自动驾驶的实现思路，我们首先通过各种不同的sensors获取周围环境的数据(RGB或RGBD图像，三维点云等)，再使用环境感知算法分析数据，得到感知定位结果并送入Planning规划环节。在Planning环节中通过对感知的环境结果进行分析，做出行为路线等规划，做出决策，车辆控制单元接收到决策，从硬件上操控车辆实现各种驾驶操作。\n车道线检测作为环境感知中非常重要的一部分，对于车辆驾驶决策有以下几点作用：\n 判断当前车辆所在车道，并保持车辆在车道内行驶防止偏向变道。 变道时判断变道行驶角度，并决定何时变道结束。 判断其他车辆所在车道，并预测其他车辆驾驶可能驾驶轨迹。  车道线检测的定义：\n输出有多种形式，根据不同方法有不同输出，可以为instances的mask，我直接输出检测出的mask，也可以为一些点，将这些点连为直线或曲线便为车道线，也可为一些参数，通过这些参数拟合曲线。\n车道线检测主要的难点：\n 遮挡严重，线为一段一段的而我们需要补全，同时可能路面有磨损 有些地方车道线看不清 线又细又长，不想目标检测 语义分割，我们有大块物体可供检测分割，车道线是细长的，在图像中比例不大。 实时性，因为我们需要在自动驾驶中使用，所以需要实时性。  2.Related Work 车道线检测的工作主要有下面几个方向：\n Traditional methods Semantic / instance segmentation-based New formulation (gridding, polynomial, anchor-based, etc.)  传统方法，语义/实例分割方法以及一些比较新奇的思路。传统方法实用性较差，目前大部分方向都集中于第2、3类。 97年的传统方法，首先将RGB转为灰度图，再做高斯模糊，然后用Canny算子检测边缘部分，霍夫变换检测出图像中的直线。所得到的直线并不知道直线的起点与终点所以就如图所示两条直线，所适用场景比较局限。\n两个分支，一个学习pixel embedding一个学习mask，将预测出的线的位置乘以embedding，再用聚类分出来不同的线。此方法思路比较简单，但依赖于聚类，也同样不知道车道线起始与终点，效果并不是很好。\n基于语义分割的很直接的方法，K条线则为K个类别，每条线对应一个类别，最终输出一张含有多个类别的mask，则输出了多条线。本篇工作还用了类似RNN方法，把信息在H与W维度上进行传递。\n后续好多基于分割的方法都致力于将模型轻量化，如上图，第一个方法使用蒸馏，第二个方法使用NAS。 下面这种方法就是Gridding，将图像分成多个小块，我个人理解就是将图像进行下采样，通过各种方式预测出来的grids作为点，最后连接成为车道线。还有其他等等新奇的方法……\n3.RESA 论文地址：RESA\nIntuation： 作者一开始的想法跟我一样\u0026hellip;.：车道线检测看起来就是语义分割，那么我们直接用语义分割当中的算法训练不就可以了吗？作者进行了实验(deeplab)发现语义分割算法得到效果很差，于是有了以下分析：\nWhy classical segmantic segmentation does not work?\n Severe occlusion \u0026amp; ambiguous lanes Sparse supervisory signals inherent in lane annotations (thin and long)  主要来说就是车道线这种特殊case的特殊性：跟语义分割不同，车道线所占区域很窄很小，就如同语义分割中电线杆类别，很容易误检错检，与此同时语义分割是所见即所得，但是车道线因为有虚线所以还需要算法进行自动补全，这是语义分割算法所缺失的 (本次分享及作者的论文其实感觉主要就是解决这个问题的，但是感觉他的特征传递方法work的原因并不是作者想的那样)。","title":"车道线检测LaneDetection"},{"content":"Windows Terminal配置过程\nWindows Terminal Windows Terminal 作为一名新晋的Windows终端，当然要来试一下。 目前Windows Terminal已经趋于成熟，个人感觉已经可以让它成为主力终端， 它实现了社区用户热切期望的许多功能(如多标签、主题样式、可配置性、富文本等)，并保持了快速与高效，不会消耗大量内存与电量。下面简单记录一下配置过程。\nWindows Ternimal GitRep\n Windows Terminal Installation Windows Terminal已经在微软商店上架，如果可已登录microsoft store，直接在商店搜索安装即可。\n如果没有办法使用，可以在release 下载Microsoft.WindowsTerminal_1.1.1671.0_8wekyb3d8bbwe.msixbundle直接安装即可。\n也可以用chocolatey安装：\nchoco install microsoft-windows-terminal 安装好后，WT的界面是有些丑的\u0026hellip; 下面讲一下如何进一步配置WT。\n Windows Terminal Settings 首先我们要进入Windows Terminal的配置文件，在下拉菜单中，选择设置/Settings，这一操作会使用系统默认文本编辑器打开Windows Terminal的配置文件。 配置文件是一个JSON格式文件，我们可以在其中定义全部Windows Terminal的属性。 结构非常清晰，大致上，配置包含如下几个部分：\n 全局属性：位于最外侧，包含设置亮暗主题、默认Profile等项目的配置。 profiles：主要功能为定义从下拉菜单中唤起的各种环境(如PowerShell，WSL，cmd等)，以及各种环境的显示方案(主题、背景、字体等)。 schemes：配色主题，可以去iTerm2-Color-Schemes里找喜欢的 keybindings：自定义快捷键的绑定。   Appearance Configuration 调整背景\nWindows Terminal的背景可以是一种纯色，也可以是一张高清壁纸，GIF动图等。纯色背景可以直接设为默认，也可以根据你的colorSchemes(我们的配色主题)改变，也可以在profiles的每个环境里面单独设置。同时我们让背景添加透明的亚克力着色，就可以使用下面三条指令：\n\u0026quot;profiles\u0026quot;: { \u0026quot;defaults\u0026quot;: { // Put settings here that you want to apply to all profiles. \u0026quot;background\u0026quot;: \u0026quot;#013456\u0026quot;, \u0026quot;useAcrylic\u0026quot;: true, \u0026quot;acrylicOpacity\u0026quot;: 0.8 }, 当然我们也可以让一张图片作为背景，我们首先进入Windows Terminal安装目录C:\\Users\\{用户名}\\AppData\\Local\\Packages\\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe里面的RoamingState文件夹，将壁纸放入其中。之后在配置文件加入以下内容：\n{ \u0026quot;backgroundImage\u0026quot;: \u0026quot;ms-appdata:///roaming/wallhaven-md5e58.png\u0026quot;, \u0026quot;backgroundImageStretchMode\u0026quot;: \u0026quot;uniformToFill\u0026quot;, \u0026quot;backgroundImageOpacity\u0026quot;: 0.6 } 这样我们的背景就添加进去啦！\n 更换文本背景主题\n这里推荐全网最丰富的终端配色方案：iTerm2-Color-Schemes。找到喜欢的主题风格，记下名字，去windowsterminal中找到相应json文件，复制其中内容到settings.json的schemes中： 然后在相应环境里面添加\u0026quot;colorScheme\u0026quot;: \u0026quot;Seafoam Pastel\u0026quot;,就可以啦！  配置所启动的环境\nWindows Terminal唤起环境时，是用配置文件里面的commandline这一属性定义的命令来进入相应环境。所以我们可以自定义执行的命令。我们以SSH远程登录为例子来介绍：\n默认的环境就是cmd与powershell了：\n{ \u0026quot;guid\u0026quot;: \u0026quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Windows PowerShell\u0026quot;, \u0026quot;colorScheme\u0026quot;: \u0026quot;Seafoam Pastel\u0026quot;, \u0026quot;commandline\u0026quot;: \u0026quot;powershell.exe\u0026quot;, \u0026quot;hidden\u0026quot;: false }, 我们可以在唤起时同时执行ssh命令，用一个不同的UUID(在线UUID生成器)来新建一个选项：\n{ \u0026quot;guid\u0026quot;: \u0026quot;{a060905f-d089-43d9-9422-cd748e7f0230}\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;SSH Lab\u0026quot;, \u0026quot;colorScheme\u0026quot;: \u0026quot;Seafoam Pastel\u0026quot;, \u0026quot;commandline\u0026quot;: \u0026quot;powershell.exe ssh root@10.0.0.1\u0026quot;, \u0026quot;hidden\u0026quot;: false }, 如果想要更加美观，还可以添加一个图标： { \u0026ldquo;icon\u0026rdquo;: \u0026ldquo;ms-appdata:///roaming/icon.png\u0026rdquo; }\n进入WSL同理可用这个自己定义一个。\n 绑定快捷键\n在 Windows Terminal 的配置文件末尾，我们可以在 \u0026quot;keybindings\u0026quot;: [] 里定义其快捷键绑定。默认的 Windows Terminal 快捷键实际上就非常好用，可以用来快速开启某个环境、实施分屏操作等。这里举几个比较典型的、无需设置即可使用的例子：\n Ctrl + Shift + T 打开新标签页 Ctrl + Shift + 1 进入配置文件中定义的第一个环境（Ctrl + Shift + 2 进入第二个，以此类推） Alt + Shift + - 横向分屏；Alt + Shift + + 纵向分屏 Ctrl + + 放大、Ctrl + - 缩小、Ctrl + 0 恢复默认缩放比例  我们可以在按住 Alt 的时候，点击 Windows Terminal 下拉菜单的「设置」，进入 Windows Terminal 自动生成的默认配置文件（不要更改这一文件，更改也不会有用的！）。在文件的最后，有 Windows Terminal 默认快捷键绑定可以参考：\n","permalink":"https://cynicsss.github.io/posts/windowsterminal/","summary":"Windows Terminal配置过程\nWindows Terminal Windows Terminal 作为一名新晋的Windows终端，当然要来试一下。 目前Windows Terminal已经趋于成熟，个人感觉已经可以让它成为主力终端， 它实现了社区用户热切期望的许多功能(如多标签、主题样式、可配置性、富文本等)，并保持了快速与高效，不会消耗大量内存与电量。下面简单记录一下配置过程。\nWindows Ternimal GitRep\n Windows Terminal Installation Windows Terminal已经在微软商店上架，如果可已登录microsoft store，直接在商店搜索安装即可。\n如果没有办法使用，可以在release 下载Microsoft.WindowsTerminal_1.1.1671.0_8wekyb3d8bbwe.msixbundle直接安装即可。\n也可以用chocolatey安装：\nchoco install microsoft-windows-terminal 安装好后，WT的界面是有些丑的\u0026hellip; 下面讲一下如何进一步配置WT。\n Windows Terminal Settings 首先我们要进入Windows Terminal的配置文件，在下拉菜单中，选择设置/Settings，这一操作会使用系统默认文本编辑器打开Windows Terminal的配置文件。 配置文件是一个JSON格式文件，我们可以在其中定义全部Windows Terminal的属性。 结构非常清晰，大致上，配置包含如下几个部分：\n 全局属性：位于最外侧，包含设置亮暗主题、默认Profile等项目的配置。 profiles：主要功能为定义从下拉菜单中唤起的各种环境(如PowerShell，WSL，cmd等)，以及各种环境的显示方案(主题、背景、字体等)。 schemes：配色主题，可以去iTerm2-Color-Schemes里找喜欢的 keybindings：自定义快捷键的绑定。   Appearance Configuration 调整背景\nWindows Terminal的背景可以是一种纯色，也可以是一张高清壁纸，GIF动图等。纯色背景可以直接设为默认，也可以根据你的colorSchemes(我们的配色主题)改变，也可以在profiles的每个环境里面单独设置。同时我们让背景添加透明的亚克力着色，就可以使用下面三条指令：\n\u0026quot;profiles\u0026quot;: { \u0026quot;defaults\u0026quot;: { // Put settings here that you want to apply to all profiles. \u0026quot;background\u0026quot;: \u0026quot;#013456\u0026quot;, \u0026quot;useAcrylic\u0026quot;: true, \u0026quot;acrylicOpacity\u0026quot;: 0.","title":"WindowsTerminal"},{"content":"剑指offer51-60题\n51题目描述 构建乘积数组\n给定一个数组A[0,1,\u0026hellip;,n-1],请构建一个数组B[0,1,\u0026hellip;,n-1],其中B中的元素B[i]=A[0]A[1]\u0026hellip;*A[i-1]A[i+1]\u0026hellip;*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * \u0026hellip; * A[n-1]，B[n-1] = A[0] * A[1] * \u0026hellip; * A[n-2];）\n思路1 直接暴力两个循环。。\n代码 class Solution { public: vector\u0026lt;int\u0026gt; multiply(const vector\u0026lt;int\u0026gt;\u0026amp; A) { vector\u0026lt;int\u0026gt; result; int temp = 1; if(A.size() == 0) return result; for(int i = 0; i \u0026lt; A.size(); i++) { temp = 1; for(int j = 0; j \u0026lt; A.size(); j++) { if(j == i) continue; else { temp *= A[j]; } } result.push_back(temp); } return result; } }; 思路2 //B[i]=A[0]A[1]\u0026hellip;*A[i-1]A[i+1]\u0026hellip;A[n-1]\n//从左到右算 B[i]=A[0]A[1]\u0026hellip;A[i-1]\n//从右到左算B[i]=A[i+1]\u0026hellip;*A[n-1]\n代码 class Solution { public: vector\u0026lt;int\u0026gt; multiply(const vector\u0026lt;int\u0026gt;\u0026amp; A) { int n=A.size(); vector\u0026lt;int\u0026gt; b(n); int ret=1; for(int i=0;i\u0026lt;n;ret*=A[i++]){ b[i]=ret; } ret=1; for(int i=n-1;i\u0026gt;=0;ret*=A[i--]){ b[i]*=ret; } return b; } }; 52题目描述 正则表达式匹配\n请实现一个函数用来匹配包括'.\u0026lsquo;和\u0026rsquo;\u0026lsquo;的正则表达式。模式中的字符\u0026rsquo;.\u0026lsquo;表示任意一个字符，而\u0026rsquo;\u0026lsquo;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\u0026quot;aaa\u0026quot;与模式\u0026quot;a.a\u0026quot;和\u0026quot;abaca\u0026quot;匹配，但是与\u0026quot;aa.a\u0026quot;和\u0026quot;ab*a\u0026quot;均不匹配\n思路 使用递归\n 首先，考虑特殊情况： 1\u0026gt;两个字符串都为空，返回true 2\u0026gt;当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法 匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成 功的，比如第二个字符串是“a*a*a*a*”,由于‘*’之前的元素可以出现0次， 所以有可能匹配成功） 之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern 下一个字符可能是‘*’， 这里我们分两种情况讨论：pattern下一个字符为‘*’或 不为‘*’： 1\u0026gt;pattern下一个字符不为‘*’：这种情况比较简单，直接匹配当前字符。如果 匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的 “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的 当前字符为‘.’,同时str的当前字符不为‘\\0’。 2\u0026gt;pattern下一个字符为‘*’时，稍微复杂一些，因为‘*’可以代表0个或多个。 这里把这些情况都考虑到： a\u0026gt;当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位， 跳过这个‘*’符号； b\u0026gt;当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符 不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时， 由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a； 当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配） 之后再写代码就很简单了。 代码 class Solution { public: bool match(char* str, char* pattern) { if(*str == '\\0' \u0026amp;\u0026amp; *pattern == '\\0') return true; if(*str != '\\0' \u0026amp;\u0026amp; *pattern == '\\0') return false; if(*(pattern + 1) != '*') { if((*pattern == *str) || (*str != '\\0' \u0026amp;\u0026amp; *pattern == '.')) return match(str + 1, pattern + 1); else return false; } else { if((*pattern == *str) || (*str != '\\0' \u0026amp;\u0026amp; *pattern == '.')) return match(str + 1, pattern) || match(str, pattern + 2); else return match(str, pattern + 2); } } }; 53题目描述 表示数值的字符串\n请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\u0026quot;+100\u0026quot;,\u0026ldquo;5e2\u0026rdquo;,\u0026quot;-123\u0026quot;,\u0026ldquo;3.1416\u0026quot;和\u0026rdquo;-1E-16\u0026quot;都表示数值。 但是\u0026quot;12e\u0026quot;,\u0026ldquo;1a3.14\u0026rdquo;,\u0026ldquo;1.2.3\u0026rdquo;,\u0026quot;+-5\u0026quot;和\u0026quot;12e+4.3\u0026quot;都不是。\n思路 依旧是各路判断，判断条件见注释。\n代码 class Solution { public: bool isNumeric(char* string) { if(*string == '\\0') return false; bool symbol = false, demical = false, hasE = false; for(int i = 0; i \u0026lt; strlen(string); i++) { if(string[i] == 'e' || string[i] == 'E') { if(hasE) return false; //E后面不能再有E if(i == (strlen(string) - 1)) return false; //E不能在数值末尾 hasE = true; continue; } else if(string[i] == '+' || string[i] == '-') { if(symbol \u0026amp;\u0026amp; string[i - 1] != 'E' \u0026amp;\u0026amp; string[i - 1] != 'e') return false; //符号出现第二次必须在E或e后面 if(!symbol \u0026amp;\u0026amp; i \u0026gt; 0 \u0026amp;\u0026amp; string[i - 1] != 'e' \u0026amp;\u0026amp; string[i - 1] != 'E') return false; //符号出现第一次符号且不在开头的话 同样也需要在E或e后面 symbol = true; continue; } else if(string[i] == '.') { if(hasE || demical) return false; //.不能出现两次或E的后面 这里一个疑问是.为什么能在开头 demical = true; continue; } else if(string[i] \u0026lt; '0' || string[i] \u0026gt; '9') return false; } return true; } }; 54题目描述 字符流中第一个不重复的字符\n请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符\u0026quot;go\u0026quot;时，第一个只出现一次的字符是\u0026quot;g\u0026quot;。当从该字符流中读出前六个字符“google\u0026quot;时，第一个只出现一次的字符是\u0026quot;l\u0026quot;。\n思路 建立一个256大小的数组用来记录256个字符出现的次数，然后直接在里面寻找出现一次的就行了。重点在于知道256字符。\n代码 class Solution { public: int count[256] = {0}; string s; //Insert one char from stringstream void Insert(char ch) { s += ch; count[int(ch)]++; } //return the first appearence once char in current stringstream char FirstAppearingOnce() { char result = '#'; for(int i = 0; i \u0026lt; s.size(); i++) { if(count[int(s[i])] == 1) { result = s[i]; break; } } return result; } }; 55题目描述 链表中环的入口结点\n给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。\n思路1 设置快慢指针，都从链表头出发，快指针每次走两步，慢指针一次走一步，假如有环，一定相遇于环中某点(结论1)。接着让两个指针分别从相遇点和链表头出发，两者都改为每次走一步，最终相遇于环入口(结论2)。以下是两个结论证明：\n两个结论：\n1、设置快慢指针，假如有环，他们最后一定相遇。\n2、两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。\n证明结论1：设置快慢指针fast和low，fast每次走两步，low每次走一步。假如有环，两者一定会相遇（因为low一旦进环，可看作fast在后面追赶low的过程，每次两者都接近一步，最后一定能追上）。\n证明结论2：\n设：\n链表头到环入口长度为\u0026ndash;a\n环入口到相遇点长度为\u0026ndash;b\n相遇点到环入口长度为\u0026ndash;c\n则：相遇时\n快指针路程=a+(b+c)k+b ，k\u0026gt;=1 其中b+c为环的长度，k为绕环的圈数（k\u0026gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。\n慢指针路程=a+b\n快指针走的路程是慢指针的两倍，所以：\n（a+b）*2=a+(b+c)k+b\n化简可得：\na=(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度。其中k\u0026gt;=1,所以k-1\u0026gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* EntryNodeOfLoop(ListNode* pHead) { if(pHead == NULL) return NULL; ListNode* fast = pHead; ListNode* slow = pHead; while(fast \u0026amp;\u0026amp; fast -\u0026gt; next) { fast = fast -\u0026gt; next -\u0026gt; next; slow = slow -\u0026gt; next; if(fast == slow) break; } if(fast == NULL || fast -\u0026gt; next == NULL) return NULL; slow = pHead; while(slow != fast) { fast = fast -\u0026gt; next; slow = slow -\u0026gt; next; } return slow; } }; 思路2 这个思路要比1好推断出来。\n首先先计算环中结点个数。计算方法：（设置快慢两个指针，如果有环，则两者一定会相遇且相遇在环中）。从相遇点转一圈找到环的个数。\n然后再设置两个快慢指针，快的先走环个数步，然后两者一起往后走 当两者相遇时，就是入口。\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* EntryNodeOfLoop(ListNode* pHead) { if(pHead==NULL)return NULL; //先计算环中结点的个数 //快慢指针相遇结点一定在环中 ListNode *pFast=pHead,*pSlow=pHead-\u0026gt;next; while(pFast!=NULL\u0026amp;\u0026amp;pSlow!=NULL\u0026amp;\u0026amp;pFast!=pSlow){ pSlow=pSlow-\u0026gt;next; pFast=pFast-\u0026gt;next; if(pFast!=NULL) pFast=pFast-\u0026gt;next; } //开始统计环结点数 int countNum=1; ListNode *pTempNode=pFast-\u0026gt;next; if(pFast==pSlow\u0026amp;\u0026amp;pFast!=NULL){ while(pTempNode!=pFast){ pTempNode=pTempNode-\u0026gt;next; ++countNum; } } else return NULL; //再设两指针，一先一后 ListNode *pNode1=pHead,*pNode2=pHead; for(int i=0;i\u0026lt;countNum;i++){ pNode1=pNode1-\u0026gt;next; } while(pNode1!=pNode2){ pNode1=pNode1-\u0026gt;next; pNode2=pNode2-\u0026gt;next; } return pNode1; } }; 56题目描述 删除链表中重复的结点\n在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5 处理后为 1-\u0026gt;2-\u0026gt;5\n思路 见注释\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if( pHead == NULL ) return pHead; ListNode *pre = NULL; //指向前面最晚访问过的不重复结点 ListNode *p = pHead; //指向当前处理的结点 ListNode *q = NULL; //指向当前处理结点后面结点 while( p != NULL ) { //当前结点p，（其实是p指向当前结点），与它下一个结点p-\u0026gt;next的val相同，说明要删掉有这个val的所有结点 if( p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val == p-\u0026gt;val ) { q = p-\u0026gt;next; //找到q，它指向最后一个与p val相同的结点，那p 到 q （包含） 都是要删除的 while( q != NULL \u0026amp;\u0026amp; q-\u0026gt;next != NULL \u0026amp;\u0026amp; q-\u0026gt;next-\u0026gt;val == p-\u0026gt;val ) { q = q-\u0026gt;next; } //如果p指向链表中第一个元素，p -\u0026gt; ... -\u0026gt; q -\u0026gt;... , 要删除p到q, 将指向链表第一个元素的指针pHead指向q-\u0026gt;next。 if( p == pHead ) { pHead = q-\u0026gt;next; } else//如果p不指向链表中第一个元素，pre -\u0026gt; p -\u0026gt;...-\u0026gt;q -\u0026gt;... ，要删除p到q，即pre-\u0026gt;next = q-\u0026gt;next { pre-\u0026gt;next = q-\u0026gt;next; } //当前处理的p要向链表尾部移动 p = q-\u0026gt;next; } else { pre = p; p = p-\u0026gt;next; } } return pHead; } }; 57题目描述 二叉树的下一个结点\n给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n思路 分析二叉树的下一个节点，一共有以下情况：\n1.二叉树为空，则返回空；\n2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；\n3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。\n代码 /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public: TreeLinkNode* GetNext(TreeLinkNode* pNode) { if(pNode == NULL) return NULL; if(pNode -\u0026gt; right) { pNode = pNode -\u0026gt; right; while(pNode -\u0026gt; left) pNode = pNode -\u0026gt; left; return pNode; } while(pNode -\u0026gt; next != NULL) { TreeLinkNode *proot=pNode-\u0026gt;next; if(proot-\u0026gt;left==pNode) return proot; pNode=pNode-\u0026gt;next; } return NULL; } }; 58题目描述 对称的二叉树\n请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。\n思路 采用递归\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: bool isSymmetrical(TreeNode* pRoot) { return IS(pRoot, pRoot); } bool IS(TreeNode* pRoot1, TreeNode* pRoot2) { if(pRoot1 == NULL \u0026amp;\u0026amp; pRoot2 == NULL) return true; if(pRoot1 == NULL || pRoot2 == NULL) return false; if(pRoot1 -\u0026gt; val != pRoot2 -\u0026gt; val) return false; return IS(pRoot1 -\u0026gt; left, pRoot2 -\u0026gt; right) \u0026amp;\u0026amp; IS(pRoot1 -\u0026gt; right, pRoot2 -\u0026gt; left); } }; 59题目描述 按之字形顺序打印二叉树\n请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。\n思路 采用两个栈来存取所读节点，因为栈的输出是倒序，正好符合之字型输出。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; Print(TreeNode* pRoot) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; if(pRoot == NULL) return result; stack\u0026lt;TreeNode*\u0026gt; stackR; stack\u0026lt;TreeNode*\u0026gt; stackL; stackL.push(pRoot); vector\u0026lt;int\u0026gt; temp; temp.push_back(pRoot -\u0026gt; val); result.push_back(temp); temp.clear(); while(!stackL.empty() || !stackR.empty()) { while(!stackL.empty()) { TreeNode* L = stackL.top(); stackL.pop(); if(L -\u0026gt; right) { stackR.push(L -\u0026gt; right); temp.push_back(L -\u0026gt; right -\u0026gt; val); } if(L -\u0026gt; left) { stackR.push(L -\u0026gt; left); temp.push_back(L -\u0026gt; left -\u0026gt; val); } } if(!temp.empty()) { result.push_back(temp); temp.clear(); } while(!stackR.empty()) { TreeNode* R = stackR.top(); stackR.pop(); if(R -\u0026gt; left) { stackL.push(R -\u0026gt; left); temp.push_back(R -\u0026gt; left -\u0026gt; val); } if(R -\u0026gt; right) { stackL.push(R -\u0026gt; right); temp.push_back(R -\u0026gt; right -\u0026gt; val); } } if(!temp.empty()) { result.push_back(temp); temp.clear(); } } return result; } }; 60题目描述 把二叉树打印成多行\n从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。\n思路 与上一题思路一样，只不过输出顺序变为从左至右 也就是不许转换顺序，所以用两个队列就可以。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; Print(TreeNode* pRoot) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; if(pRoot == NULL) return result; queue\u0026lt;TreeNode*\u0026gt; que1; queue\u0026lt;TreeNode*\u0026gt; que2; que1.push(pRoot); vector\u0026lt;int\u0026gt; temp; temp.push_back(pRoot -\u0026gt; val); result.push_back(temp); temp.clear(); while(!que1.empty() || !que2.empty()) { while(!que1.empty()) { TreeNode* front1 = que1.front(); que1.pop(); if(front1 -\u0026gt; left) { que2.push(front1 -\u0026gt; left); temp.push_back(front1 -\u0026gt; left -\u0026gt; val); } if(front1 -\u0026gt; right) { que2.push(front1 -\u0026gt; right); temp.push_back(front1 -\u0026gt; right -\u0026gt; val); } } if(!temp.empty()) { result.push_back(temp); temp.clear(); } while(!que2.empty()) { TreeNode* front2 = que2.front(); que2.pop(); if(front2 -\u0026gt; left) { que1.push(front2 -\u0026gt; left); temp.push_back(front2 -\u0026gt; left -\u0026gt; val); } if(front2 -\u0026gt; right) { que1.push(front2 -\u0026gt; right); temp.push_back(front2 -\u0026gt; right -\u0026gt; val); } } if(!temp.empty()) { result.push_back(temp); temp.clear(); } } return result; } }; ","permalink":"https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer51-60/","summary":"\u003cp\u003e剑指offer51-60题\u003c/p\u003e","title":"剑指offer51-60"},{"content":"剑指offer61-67题\n61题目描述 序列化二叉树\n请实现两个函数，分别用来序列化和反序列化二叉树\n二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。\n二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。\n思路 采用前序遍历，遇到空节点，存入一个特殊字符。运用递归。要熟练使用to_string() 及 stoi()，c_str() strcpy() substr() 的用法。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: void SerializeHelper(TreeNode *root, string \u0026amp;str) { if(root == NULL) { str += \u0026quot;N,\u0026quot;; return; } str += to_string(root -\u0026gt; val); str += \u0026quot;,\u0026quot;; SerializeHelper(root -\u0026gt; left, str); SerializeHelper(root -\u0026gt; right, str); } char* Serialize(TreeNode *root) { if(root == NULL) return NULL; string s = \u0026quot;\u0026quot;; SerializeHelper(root, s); char* ret = new char[s.length() + 1]; ret = strcpy(ret, s.c_str()); return ret; } TreeNode* DeserializeHelper(string\u0026amp; s) { if(s.empty()) return NULL; if(s[0] == 'N') { s = s.substr(2); return NULL; } TreeNode* newNode = new TreeNode(stoi(s)); s = s.substr(s.find(',') + 1); newNode -\u0026gt; left = DeserializeHelper(s); newNode -\u0026gt; right = DeserializeHelper(s); return newNode; } TreeNode* Deserialize(char *str) { if(str == NULL) return NULL; string s(str); return DeserializeHelper(s); } }; 62题目描述 二叉搜索树的第k个结点\n给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。\n思路 采用递归。二叉搜索树的中序遍历的输出是从小到大。所以设置一个计数器，用递归中序遍历到第k个即结果就好。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: int count = 0; TreeNode* KthNode(TreeNode* pRoot, int k) { if(pRoot != NULL) { TreeNode* node = KthNode(pRoot -\u0026gt; left, k); if(node != NULL) return node; count++; if(count == k) return pRoot; node = KthNode(pRoot -\u0026gt; right, k); if(node != NULL) return node; } return NULL; } }; 63题目描述 数据流中的中位数\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。\n思路 定义一个向量，用来保存数据流，用sort函数进行排序。\n代码 class Solution { public: vector\u0026lt;int\u0026gt; array; void Insert(int num) { array.push_back(num); } double GetMedian() { sort(array.begin(), array.end()); if(array.size() % 2 == 0) return (array[array.size() / 2] + array[array.size() / 2 - 1]) / 2.0; if(array.size() % 2 != 0) return array[array.size() / 2]; } }; 64题目描述 滑动窗口的最大值\n给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。\n思路 设置两个指针，代表窗口上下限，在窗口内部暴力查找最大值。 /还有一个双端队列的思路\n代码 class Solution { public: vector\u0026lt;int\u0026gt; maxInWindows(const vector\u0026lt;int\u0026gt;\u0026amp; num, unsigned int size) { vector\u0026lt;int\u0026gt; maxarray; if(num.empty()) return maxarray; int fast = size - 1, slow = 0; int max = 0; while(fast \u0026lt; num.size()) { max = num[slow]; for(int i = slow + 1; i \u0026lt;= fast; i++) if(num[i] \u0026gt; max) max = num[i]; maxarray.push_back(max); fast++; slow++; } return maxarray; } }; 65题目描述 矩阵中的路径\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。\n思路 分析：回溯算法\n这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的\n第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。\n重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。\n由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个\n字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。\n由于路径不能重复进入矩阵的格子，还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的\n格子和路径字符串中相应的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符\n如果4个相邻的格子都没有匹配字符串中下一个的字符，表明当前路径字符串中字符在矩阵中的定位不正确，我们需要回到前一个，然后重新定位。\n一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置\n代码 class Solution { public: bool hasPath(char* matrix, int rows, int cols, char* str) { if(rows \u0026lt;= 0 || cols \u0026lt;= 0 || str == NULL) return false; //bool* HasCount = new bool[rows * cols](); bool* HasCount = new bool[rows * cols]; memset(HasCount,false,rows*cols); for(int i = 0; i \u0026lt; rows; i++) { for(int j = 0; j \u0026lt; cols; j++) if(HasPathHelper(matrix, rows, cols, str, HasCount, i, j)) return true; } return false; } bool HasPathHelper(char* matrix, int rows, int cols, char* str, bool* HasCount, int x, int y) { if(*str == '\\0') return true; if(x \u0026lt; 0 || x \u0026gt;= rows || y \u0026lt; 0 || y \u0026gt;= cols) return false; if(HasCount[x * cols + y] || matrix[x * cols + y] != *str) return false; HasCount[x * cols + y] = true; bool temp = HasPathHelper(matrix, rows, cols, str+1, HasCount, x+1, y) || HasPathHelper(matrix, rows, cols, str+1, HasCount, x, y+1) || HasPathHelper(matrix, rows, cols, str+1, HasCount, x-1, y) || HasPathHelper(matrix, rows, cols, str+1, HasCount, x, y-1); HasCount[x * cols + y] = false; return temp; } }; 66题目描述 机器人的运动范围\n地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？\n思路 回溯法，采用递归。这里要注意要遍历所有格子，而不是找一个能包含最多格子的路径，在路径上可以任意走动。所以在计算时直接加1即可，次数不需回溯。\n代码 class Solution { public: int movingCount(int threshold, int rows, int cols) { if(rows \u0026lt;= 0 || cols \u0026lt;= 0) return 0; bool* Count = new bool[rows * cols]; memset(Count, false, rows * cols); return movingCountHelper(threshold, rows, cols, 0, 0, Count); } int movingCountHelper(int threshold, int rows, int cols, int x, int y, bool* Count) { if(x \u0026lt; 0 || x \u0026gt;= rows || y \u0026lt; 0 || y \u0026gt;= cols) return 0; if(Count[x * cols + y] == 1) return 0; int col_sum = 0, row_sum = 0; int temp_x = x, temp_y = y; if(x == 0) row_sum = 0; if(y == 0) col_sum = 0; while(temp_x \u0026gt; 0) { row_sum += (temp_x % 10); temp_x = temp_x / 10; } while(temp_y \u0026gt; 0) { col_sum += (temp_y % 10); temp_y = temp_y / 10; } if((row_sum + col_sum) \u0026lt;= threshold) { Count[x * cols + y] = 1; return 1 + movingCountHelper(threshold, rows, cols, x + 1, y, Count) + movingCountHelper(threshold, rows, cols, x - 1, y, Count) + movingCountHelper(threshold, rows, cols, x, y + 1, Count) + movingCountHelper(threshold, rows, cols, x, y - 1, Count); } return 0; } }; 67题目描述 剪绳子\n给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为k[0],k[1],\u0026hellip;,k[m]。请问k[0]xk[1]x\u0026hellip;xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n思路1 动态规划\n①求一个问题的最优解；\n②整体的问题的最优解是依赖于各个子问题的最优解；\n③小问题之间还有相互重叠的更小的子问题；\n④从上往下分析问题，从下往上求解问题；\n代码 public class Solution { public int cutRope(int n) { // n\u0026lt;=3的情况，m\u0026gt;1必须要分段，例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2, if(n==2) return 1; if(n==3) return 2; int[] dp = new int[n+1]; /* 下面3行是n\u0026gt;=4的情况，跟n\u0026lt;=3不同，4可以分很多段，比如分成1、3， 这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。 */ dp[1]=1; dp[2]=2; dp[3]=3; int res=0;//记录最大的 for (int i = 4; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;=i/2 ; j++) { res=Math.max(res,dp[j]*dp[i-j]); } dp[i]=res; } return dp[n]; } } 思路2 贪婪算法\n贪婪解法： 当n大于等于5时，我们尽可能多的剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 为什么选2，3为最小的子问题？因为2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。 为什么选长度为3？因为当n≥5时，3(n−3)≥2(n−2)\nhttps://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?f=discussion\n代码 class Solution { public: int cutRope(int number) { if(number \u0026lt; 2) return 0; if(number == 3) return 2; if(number == 2) return 1; int threecount = number / 3; if(number - (threecount * 3) == 1) threecount--; int twocount = (number - (threecount * 3)) / 2; return int(pow(3, threecount))*int(pow(2, twocount)); } }; ","permalink":"https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer61-67/","summary":"\u003cp\u003e剑指offer61-67题\u003c/p\u003e","title":"剑指offer61-67"},{"content":"剑指offer41-50题\n41题目描述 和为S的连续正数序列\n小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!\n输出描述:\n输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序\n思路 采用双指针策略，不需要使用队列，用队列反而变麻烦了。记录两个指针，一个大一个小，计算大小之间这个窗口的和。\n代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; FindContinuousSequence(int sum) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; Sequences; if(sum \u0026lt; 3) return Sequences; int small = 1; int big = 2; int temp_sum = 3; int mid = (sum + 1) / 2; while(small \u0026lt; mid) { if(temp_sum == sum) { vector\u0026lt;int\u0026gt; temp_sequence; for(int i = small; i \u0026lt;= big; i++) temp_sequence.push_back(i); Sequences.push_back(temp_sequence); } if(temp_sum \u0026gt; sum) { while(temp_sum \u0026gt; sum \u0026amp;\u0026amp; small \u0026lt; mid) { temp_sum -= small; small++; } if(temp_sum == sum) { vector\u0026lt;int\u0026gt; temp_sequence; for(int i = small; i \u0026lt;= big; i++) temp_sequence.push_back(i); Sequences.push_back(temp_sequence); } } temp_sum += ++big; } return Sequences; } }; 42题目描述 和为S的两个数字\n输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。\n输出描述:\n对应每个测试案例，输出两个数，小的先输出。\n思路1 同样采用双指针，从前往后遍历算和，和为要求的量后直接return，因为此时就算有其他满足条件的但此乘积一定是最小的\n代码 class Solution { public: vector\u0026lt;int\u0026gt; FindNumbersWithSum(vector\u0026lt;int\u0026gt; array,int sum) { vector\u0026lt;int\u0026gt; Numbers; int flag = 0; if(array.size() \u0026lt; 2) return Numbers; for(int small = 0; small \u0026lt; (array.size() - 1); small++) { for(int big = small + 1; big \u0026lt; array.size(); big++) { if(array[small] + array[big] == sum) { Numbers.push_back(array[small]); Numbers.push_back(array[big]); flag = 1; break; } } if(flag == 1) break; } return Numbers; } }; 思路2 数列满足递增，设头尾两个指针 若ai + aj == sum，就是答案（相差越远乘积越小）\n若ai + aj \u0026gt; sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1\n若ai + aj \u0026lt; sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1\nO(n)\n代码 class Solution { public: vector\u0026lt;int\u0026gt; FindNumbersWithSum(vector\u0026lt;int\u0026gt; array,int sum) { int left,right; left=0; right=array.size()-1; vector\u0026lt;int\u0026gt; result; while(left\u0026lt;right){ if(array[left]+array[right]==sum){ result.push_back(array[left]); result.push_back(array[right]); break; } if(array[left]+array[right]\u0026gt;sum){ right--; }else{ left++; } } return result; } }; 43题目描述 左旋转字符串\n汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！\n思路1 用substr函数截取字符串，然后前后调换位置即可。主要是熟悉函数的应用。\n代码 class Solution { public: string LeftRotateString(string str, int n) { string s3 = \u0026quot;\u0026quot;; if(str == \u0026quot;\u0026quot;) return s3; string s1 = str.substr(0, n); string s2 = str.substr(n, str.size() - n); s3 = s2 + s1; return s3; } }; 思路2 剑指offer书上的方法，两次翻转字符串 原理：YX = (XTYT)T\n代码 class Solution { public: string LeftRotateString(string str, int n) { reverse(str.begin(), str.end()); reverse(str.begin(), str.begin() + str.size() - n); reverse(str.begin() + str.size() - n, str.end()); return str; } }; 44题目描述 翻转单词顺序序列\n牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？\n思路 此题需要一个字符一个字符进行处理 运用string之间相加的便利性进行顺序互换\n代码 class Solution { public: string ReverseSentence(string str) { string Reverse = \u0026quot;\u0026quot;; if(str.size() == 0) return Reverse; string tmp = \u0026quot;\u0026quot;; for(int i = 0; i \u0026lt; str.size(); i++) { if(str[i] == ' ') { Reverse = \u0026quot; \u0026quot; + tmp + Reverse; tmp = \u0026quot;\u0026quot;; } else tmp += str[i]; } if(tmp.size()) Reverse = tmp + Reverse; return Reverse; } }; 45题目描述 扑克牌顺子\nLL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)\u0026hellip;他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子\u0026hellip;..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。\n思路 这题主要是阅读理解..写的花里胡哨的。 思路是先对抽到的进行排序，再看两两间像差多少。king的话作为计数，弥补相差过多。\n代码 class Solution { public: bool IsContinuous( vector\u0026lt;int\u0026gt; numbers ) { if(numbers.size() == 0) return 0; int flag = 1; int king = 0; sort(numbers.begin(), numbers.end()); for(int i = 0; i \u0026lt; numbers.size() - 1; i++) { if(numbers[i] == 0) { king++; continue; } if(numbers[i+1] - numbers[i] == 0) { flag = 0; break; } if(numbers[i+1] - numbers[i] == 1) continue; else { int a = numbers[i+1] - numbers[i] - 1; king -= a; if(king \u0026lt; 0) { flag = 0; break; } } } return flag; } }; 46题目描述 孩子们的游戏（圆圈中最后剩下的数）\n每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0\u0026hellip;m-1报数\u0026hellip;.这样下去\u0026hellip;.直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)\n如果没有小朋友，请返回-1\n思路 利用列表的函数，建立一个指针进行逐个元素遍历，遍历到哪个元素哪个元素弹出，然后继续后续的遍历直到只剩一个元素。\n这里要注意最后一个弹出时 指针要指向vector开头，如果没有此操作程序无法运行。\n代码 class Solution { public: int LastRemaining_Solution(int n, int m) { if(n \u0026lt;= 0 || m \u0026lt;= 0) return -1; vector\u0026lt;int\u0026gt; ALL; for(int i = 0; i \u0026lt; n; i++) ALL.push_back(i); int point = 0; int left = n; while(left \u0026gt; 1) { for(int i = 0; i \u0026lt; m - 1; i++) { if(point == (left - 1)) point = 0; else point++; } ALL.erase(ALL.begin() + point); if(point == (left - 1)) point = 0; left--; } return ALL[0]; } }; 47题目描述 求1+2+3+\u0026hellip;+n\n求1+2+3+\u0026hellip;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n思路 这些限制条件里面没有限制递归\u0026hellip;于是直接用了递归。\n代码 class Solution { public: int Sum_Solution(int n) { if(n == 1) return 1; return n + Sum_Solution(n - 1); } }; 48题目描述 不用加减乘除做加法\n写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n思路 //step1:按位与是查看两个数哪些二进制位都为1，这些都是进位位，结果需左移一位，表示进位后的结果\n//step2:异或是查看两个数哪些二进制位只有一个为1，这些是非进位位，可以直接加、减，结果表示非进位位进行加操作后的结果\n//step3:n1\u0026amp;n2是查看有没有进位位了，如果有，需要重复step1、step2；如果没有，保留n1、n2上二进制为1的部分，用或将之合为一个数，即为最后结果\n代码 class Solution { public: int Add(int num1, int num2) { int n1,n2; n1=(num1\u0026amp;num2)\u0026lt;\u0026lt;1; n2=num1^num2; while(n1\u0026amp;n2) { num1=n1;num2=n2; n1=(num1\u0026amp;num2)\u0026lt;\u0026lt;1; n2=num1^num2; } return n1|n2; } }; 49题目描述 把字符串转换成整数\n将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0\n输入描述：\n输入一个字符串,包括数字字母符号,可以为空\n输出描述：\n如果是合法的数值表达则返回该数字，否则返回0\n输入：\n+2147483647\n1a33\n输出：\n2147483647\n0\n思路 逐位判断，是否在0-9之中，在则转为int存入vector不在则直接返回0。最后按位将存入vecotr的数组合起来。这里要注意超出int范围的情况，超出范围需要返回0； （注：判断0-9不用单个判断！直接使用str[i]\u0026gt;=\u0026lsquo;0\u0026rsquo;\u0026amp;\u0026amp;str[i]\u0026lt;=\u0026lsquo;9\u0026rsquo;）\n代码 class Solution { public: int StrToInt(string str) { long int a = 0; int flag = 1; vector\u0026lt;int\u0026gt; single; for(int i = 0; i \u0026lt; str.size(); i++) { if(i == 0 \u0026amp;\u0026amp; str[i] == '+') continue; if(i == 0 \u0026amp;\u0026amp; str[i] == '-') { flag = 0; continue; } if(i != 0 \u0026amp;\u0026amp; str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') single.push_back(int(str[i]) - 48); else return 0; } int ten = single.size() - 1; for(int i = 0; i \u0026lt; single.size(); i++) { a += (single[i] * pow(10, ten)); ten--; } int fin = 0; if(flag == 0) a = -a; if(a \u0026lt; -2147483648 || a \u0026gt; 2147483647) return 0; else fin = a; return fin; } }; 50题目描述 数组中重复的数字\n在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。\n思路 建立一个辅助vector用来记录每个数字出现的次数，当有一个出现2次时，直接返回。如果到最后还没有则返回false。\n代码 class Solution { public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) { vector\u0026lt;int\u0026gt; count(10, 0); for(int i = 0; i \u0026lt; length; i++) { count[numbers[i]]++; if(count[numbers[i]] \u0026gt;= 2) { *duplication = numbers[i]; return true; } } return false; } }; ","permalink":"https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer41-50/","summary":"\u003cp\u003e剑指offer41-50题\u003c/p\u003e","title":"剑指offer41-50"},{"content":"剑指offer31-40题\n31题目描述 整数中1出现的次数（从1到n整数中1出现的次数）\n求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。\n思路 注意审题，1出现的次数，不是包含1的数有多少个。 问题不要想复杂了，使用简单的模10即可解决。\n代码 class Solution { public: int NumberOf1Between1AndN_Solution(int n) { int num = 0; if(n \u0026lt; 1) return 0; for(int i = 1; i \u0026lt;= n; i++) { int temp = i; while(temp) { if(temp % 10 == 1) num++; temp = temp / 10; } } return num; } }; 32题目描述 把数组排成最小的数：\n输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。\n思路 用vector自带sort函数进行排序，顺序由自己重新定义：a b转换成string后进行比较，ab\u0026lt;ba则保持顺序不变，ab\u0026gt;ba表示后面的要放到前面。这里需要熟悉vector的sort函数以及to_string，string之间的比较。https://blog.csdn.net/ihadl/article/details/7400929\n代码 class Solution { public: static bool exchange(int i, int j) { string A = \u0026quot;\u0026quot;; string B = \u0026quot;\u0026quot;; A += to_string(i); A += to_string(j); B += to_string(j); B += to_string(i); return A \u0026lt; B; } string PrintMinNumber(vector\u0026lt;int\u0026gt; numbers) { string result = \u0026quot;\u0026quot;; if(numbers.empty()) return result; sort(numbers.begin(), numbers.end(), exchange); for(int i = 0; i \u0026lt; numbers.size(); i++) result += to_string(numbers[i]); return result; } }; 33题目描述 丑数:\n把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n思路 链接：https://www.nowcoder.com/questionTerminal/6aa9e04fc3794f68acf8778237ba065b 来源：牛客网\n通俗易懂的解释： 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方***得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：\n（1）丑数数组： 1\n乘以2的队列：2\n乘以3的队列：3\n乘以5的队列：5\n选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（2）丑数数组：1,2\n乘以2的队列：4\n乘以3的队列：3，6\n乘以5的队列：5，10\n选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（3）丑数数组：1,2,3\n乘以2的队列：4,6\n乘以3的队列：6,9\n乘以5的队列：5,10,15\n选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（4）丑数数组：1,2,3,4\n乘以2的队列：6，8\n乘以3的队列：6,9,12\n乘以5的队列：5,10,15,20\n选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（5）丑数数组：1,2,3,4,5\n乘以2的队列：6,8,10，\n乘以3的队列：6,9,12,15\n乘以5的队列：10,15,20,25\n选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；\n…………………… 疑问：\n1.为什么分三个队列？\n丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；\n2.为什么比较三个队列头部最小的数放入丑数数组？\n因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。\n实现思路：\n我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；\n（1）1\n|2\n|3\n|5\n目前指针指向0,0,0，队列头arr[0] * 2 = 2, arr[0] * 3 = 3, arr[0] * 5 = 5\n（2）1 2\n2 |4\n|3 6\n|5 10\n目前指针指向1,0,0，队列头arr[1] * 2 = 4, arr[0] * 3 = 3, arr[0] * 5 = 5\n（3）1 2 3\n2| 4 6\n3 |6 9\n|5 10 15\n目前指针指向1,1,0，队列头arr[1] * 2 = 4, arr[1] * 3 = 6, arr[0] * 5 = 5\n代码 class Solution { public: int GetUglyNumber_Solution(int index) { if (index \u0026lt; 7)return index; vector\u0026lt;int\u0026gt; res(index); res[0] = 1; int t2 = 0, t3 = 0, t5 = 0, i; for (i = 1; i \u0026lt; index; ++i) { res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5)); if (res[i] == res[t2] * 2)t2++; if (res[i] == res[t3] * 3)t3++; if (res[i] == res[t5] * 5)t5++; } return res[index - 1]; } }; 34题目描述 第一个只出现一次的字符\n在一个字符串(0\u0026lt;=字符串长度\u0026lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。\n思路1 建立两个辅助数组和一个辅助字符串。第一个辅助数组count用来记录每个字符出现的次数，第二个辅助数组address用来记录字符出现的地址，辅助字符串用来记录出现的字符。三者在位置上对应。遍历整个字符串，直接将出现的字符相应属性记录在辅助数组与字符串中即可。 最后遍历count找到第一个为1的index，其对应的address就是这个字符的位置。\n代码 class Solution { public: int FirstNotRepeatingChar(string str) { int flag = 0; vector\u0026lt;int\u0026gt; count; vector\u0026lt;char\u0026gt; character; vector\u0026lt;int\u0026gt; address; for(int i = 0; i \u0026lt; str.length(); i++) { flag = 0; if(count.empty()) { count.push_back(1); character.push_back(str[i]); address.push_back(i); continue; } for(int j = 0; j \u0026lt; character.size(); j++) { if(str[i] == character[j]) { count[j]++; flag = 1; } } if(flag) continue; count.push_back(1); character.push_back(str[i]); address.push_back(i); } for(int i = 0; i \u0026lt; count.size(); i++) { if(count[i] == 1) return address[i]; } return -1; } }; 思路2 使用STL的map(1对1关联容器)记录， 更加方便。\n代码 class Solution { public: int FirstNotRepeatingChar(string str) { map\u0026lt;char, int\u0026gt; mp; for(int i = 0; i \u0026lt; str.size(); ++i) mp[str[i]]++; for(int i = 0; i \u0026lt; str.size(); ++i){ if(mp[str[i]]==1) return i; } return -1; } }; 35题目描述 数组中的逆序数\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007\n输入描述:\n题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size\u0026lt;=10^4 对于%75的数据,size\u0026lt;=10^5 对于%100的数据,size\u0026lt;=2*10^5 示例1：\n输入 1,2,3,4,5,6,7,0 输出 7 思路 思路分析：\n看到这个题目，我们的第一反应是顺序扫描整个数组。每扫描到一个数组的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n个数字。由于每个数字都要和O(n)这个数字比较，因此这个算法的时间复杂度为O(n^2)。\n我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿ta和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。\n(a) 把长度为4的数组分解成两个长度为2的子数组；\n(b) 把长度为2的数组分解成两个成都为1的子数组；\n(c) 把长度为1的子数组 合并、排序并统计逆序对 ；\n(d) 把长度为2的子数组合并、排序，并统计逆序对；\n在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。\n接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。\n我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。\n过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。\n交换copy和data是因为：\n1.在每次的操作中，数值的比较都是采用当前传入函数中第一项，也就是data；比较的结果都存放到copy中；也就意味着此时copy中是经过此次调用的结果。\n2.从最底层返回时，进入了(start == end)的情形，data 和 copy 完全没有修改，此时copy和data还是一样的。\n3.进入倒数第二层时，程序进入上图26行以后部分，copy是部分排序后的新数组，data是旧数组。注意这里都是传值的调用，数组都是直接修改的。\n倒数第二层使用的copy其实是倒数第三层中的data,这就确保了倒数第三层进入26行以后时，数据比较使用的data是最新排序的数组。\n4.倒数第三层将排序的结果存入copy中。程序在倒数第四层进入26行后，使用的data数组为刚刚倒数第三层中的最新排序的copy.\n5.也就是说，在每次程序进入26行时，此时的data是最新的排序结果，copy是次新的结果。 在最后一次进入26行以后时，copy为完整排序后的结果，data是次新的结果。\n然而这里第一个类内函数调用第二个函数时，data和copy的顺序没有改变，所以最后结果应该copy是完整排序的结果.data是差一步完成排序的结果。以输入[7,5,6,4], 最后的结果copy[4,5,6,7], data[5,7,4,6].\n代码 class Solution { public: int InversePairs(vector\u0026lt;int\u0026gt; data) { if(data.empty()) return 0; vector\u0026lt;int\u0026gt; copy; for(int i = 0; i \u0026lt; data.size(); i++) copy.push_back(data[i]); int length = data.size(); long long count = MergeSort(data, copy, 0, length - 1); return count % 1000000007; } long long MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; data, vector\u0026lt;int\u0026gt;\u0026amp; copy, int start, int end) { if(start == end) { copy[start] = data[start]; return 0; } int mid = (end - start) / 2; long long left = MergeSort(copy, data, start, start + mid); long long right = MergeSort(copy, data, start + mid + 1, end); int left_point = start + mid; int right_point = end; int index_copy = end; long long count = 0; while(left_point \u0026gt;= start \u0026amp;\u0026amp; right_point \u0026gt;= start + mid + 1) { if(data[left_point] \u0026gt; data[right_point]) { count = count + (right_point - (start + mid + 1) + 1); copy[index_copy--] = data[left_point--]; } else { copy[index_copy--] = data[right_point--]; } } while(left_point \u0026gt;= start) copy[index_copy--] = data[left_point--]; while(right_point \u0026gt;= start + mid + 1) copy[index_copy--] = data[right_point--]; return count + left + right; } }; 36题目描述 两个链表的第一个公共结点\n输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）\n思路 本题首先要明白，公共结点代表着，两个链表拥有公共尾部(因为只有一个next)。 所以先计算两者长度，然后让长的先走两个链表长度差后 再一起走，当相同时，就是第一个公共结点。\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) { if(pHead1 == NULL || pHead2 == NULL) return NULL; int pHead1_len = 0; int pHead2_len = 0; ListNode* p1 = pHead1; ListNode* p2 = pHead2; while(p1 != NULL) { pHead1_len++; p1 = p1 -\u0026gt; next; } while(p2 != NULL) { pHead2_len++; p2 = p2 -\u0026gt; next; } p1 = pHead1; p2 = pHead2; int difference = 0; if(pHead1_len \u0026gt; pHead2_len) { difference = pHead1_len - pHead2_len; while(difference) { p1 = p1 -\u0026gt; next; difference--; } } if(pHead2_len \u0026gt; pHead1_len) { difference = pHead2_len - pHead1_len; while(difference) { p2 = p2 -\u0026gt; next; difference--; } } while(p1 != NULL) { if(p1 == p2) return p1; else { p1 = p1 -\u0026gt; next; p2 = p2 -\u0026gt; next; } } return NULL; } }; 37题目描述 数字在排序数组中出现的次数\n统计一个数字在排序数组中出现的次数。\n思路1 我所采用的二分查找变形。使用二分查找，找到k出现的最左位置，再向后遍历，如果重复则加一 不重复则break；\n代码 class Solution { public: int GetNumberOfK(vector\u0026lt;int\u0026gt; data ,int k) { if(data.empty()) return 0; int lower = get_lower(data, k); int count = 0; if(lower != -1) { while(lower \u0026lt;= data.size() - 1) { if(data[lower] == k) { count++; lower++; continue; } else break; } } return count; } int get_lower(vector\u0026lt;int\u0026gt; data, int k) { int start = 0; int end = data.size() - 1; int mid = (start + end) / 2; int lower = -1; while(start \u0026lt;= end) { if(k == data[start]) { lower = start; break; } else if(k == data[mid]) { lower = mid; end = mid - 1; } else if(k \u0026lt; data[mid]) end = mid - 1; else if(k \u0026gt; data[mid]) start = mid + 1; mid = (start + end) / 2; } return lower; } }; 思路2 由于数组有序，所以使用二分查找方法定位k的第一次出现位置和最后一次出现位置 (找到上界下界，此程序有bug，有特殊测试用例则无法通过 （还有一种情况不严谨，就是比如1，2，3，4，6，7寻找5，会返回6的下标但是此刻数组中不存在5）)\n代码 链接：https://www.nowcoder.com/questionTerminal/70610bf967994b22bb1c26f9ae901fa2 来源：牛客网 class Solution { public: int GetNumberOfK(vector\u0026lt;int\u0026gt; data ,int k) { int lower = getLower(data,k); int upper = getUpper(data,k); return upper - lower + 1; } //获取k第一次出现的下标 int getLower(vector\u0026lt;int\u0026gt; data,int k){ int start = 0,end = data.size()-1; int mid = (start + end)/2; while(start \u0026lt;= end){ if(data[mid] \u0026lt; k){ start = mid + 1; }else{ end = mid - 1; } mid = (start + end)/2; } return start; } //获取k最后一次出现的下标 int getUpper(vector\u0026lt;int\u0026gt; data,int k){ int start = 0,end = data.size()-1; int mid = (start + end)/2; while(start \u0026lt;= end){ if(data[mid] \u0026lt;= k){ start = mid + 1; }else{ end = mid - 1; } mid = (start + end)/2; } return end; } }; 38题目描述 二叉树的深度\n输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。\n思路1 使用递归，左子树深度大则返回左子树深度，反之返回右子树\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: int TreeDepth(TreeNode* pRoot) { if(pRoot == NULL) return 0; int depth = 0; depth = count(pRoot, depth); return depth; } int count(TreeNode* p, int depth) { depth++; int left_depth = depth; int right_depth = depth; if(p -\u0026gt; left != NULL) left_depth = count(p -\u0026gt; left, depth); if(p -\u0026gt; right != NULL) right_depth = count(p -\u0026gt; right, depth); return max(left_depth, right_depth); } }; 思路2 使用队列，进行层次遍历\n代码 class Solution { public: int TreeDepth(TreeNode* pRoot) { if (!pRoot) return 0; queue\u0026lt;TreeNode*\u0026gt; que; que.push(pRoot);int depth=0; while (!que.empty()) { int size=que.size(); depth++; for (int i=0;i\u0026lt;size;i++) { //一次处理一层的数据 TreeNode *node=que.front(); que.pop(); if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } } return depth; } }; 39题目描述 平衡二叉树\n输入一棵二叉树，判断该二叉树是否是平衡二叉树。\n思路 使用递归，这里要注意平衡二叉树的定义，一个平衡二叉树中每一个单独的子树也是一个平衡二叉树。平衡二叉树：左子树右子树深度之差不超过1。\n使用了两个递归，一个是判断当前子树左右深度是否超过1(是否是平衡二叉树)， 另一个是计算深度。 如果其中一个子树不是平衡二叉树，则直接返回否。\n代码 class Solution { public: bool IsBalanced_Solution(TreeNode* pRoot) { if(pRoot == NULL) return 1; return IsBalanced(pRoot, 1); } bool IsBalanced(TreeNode* pRoot, bool is) { if(is == false) return false; int right_depth = 0; int left_depth = 0; bool right_is = 1; bool left_is = 1; if(pRoot -\u0026gt; left != NULL) { left_depth = CountDepth(pRoot -\u0026gt; left, left_depth); left_is = IsBalanced(pRoot -\u0026gt; left, 1); } if(pRoot -\u0026gt; right != NULL) { right_depth = CountDepth(pRoot -\u0026gt; right, right_depth); right_is = IsBalanced(pRoot -\u0026gt; right, 1); } if(abs(right_depth - left_depth) \u0026gt; 1) is = 0; return is \u0026amp;\u0026amp; right_is \u0026amp;\u0026amp; left_is; } int CountDepth(TreeNode* pRoot, int depth) { depth++; int left_depth = depth; int right_depth = depth; if(pRoot -\u0026gt; left != NULL) left_depth = CountDepth(pRoot -\u0026gt; left, left_depth); if(pRoot -\u0026gt; right != NULL) right_depth = CountDepth(pRoot -\u0026gt; right, right_depth); return max(left_depth, right_depth); } }; 40题目描述 数组中只出现一次的数字\n一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。\n思路 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。\n这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。\n有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。\n我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。\n现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。\n代码 class Solution { public: void FindNumsAppearOnce(vector\u0026lt;int\u0026gt; data,int* num1,int *num2) { if(data.size() \u0026lt; 2) return ; int temp = data[0]; for(int i = 1; i \u0026lt; data.size(); i++) temp ^= data[i]; if(temp == 0) return ; int index = 0; while((temp \u0026amp; 1) == 0) { temp = temp \u0026gt;\u0026gt; 1; index++; } *num1 = 0; *num2 = 0; for(int i = 0; i \u0026lt; data.size(); i++) { if(IsBit(data[i], index)) *num1 ^= data[i]; else *num2 ^= data[i]; } } bool IsBit(int i, int index) { i = i \u0026gt;\u0026gt; index; return (i \u0026amp; 1); } }; ","permalink":"https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer31-40/","summary":"\u003cp\u003e剑指offer31-40题\u003c/p\u003e","title":"剑指offer31-40"},{"content":"剑指offer21-30题\n21题目描述 栈的压入、弹出序列：\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n思路 我想的思路是借用一个辅助栈，进行真实的入栈出栈，判断第二个序列与栈顶是否相同，如果不相同，则进行序列1的压入栈。在压入是判断压入的是否与序列2当前元素相等，如果相等，则视为直接出栈，然后返回来判断序列2的下一个元素是否与栈顶相等，相等的话则pop，序列2继续往后走，以此循环。最后判断辅助栈是否为空，如果为空，则出栈顺序没毛病，返回1，如果不为空，则出栈不符合规则，返回0；\n代码 class Solution { public: bool IsPopOrder(vector\u0026lt;int\u0026gt; pushV,vector\u0026lt;int\u0026gt; popV) { stack\u0026lt;int\u0026gt; aux; if(pushV.size() != popV.size()) return false; if(pushV.empty() || popV.empty()) return false; int i = 0, j = 0; for(; i \u0026lt; pushV.size() \u0026amp;\u0026amp; j \u0026lt; popV.size();) { if(aux.empty()) { aux.push(pushV[i]); i++; continue; } if(aux.top() != popV[j]) { for(; i \u0026lt; pushV.size(); ) { if(pushV[i] != popV[j]) { aux.push(pushV[i]); i++; } if(pushV[i] == popV[j]) { i++; j++; break; } } continue; } if(aux.top() == popV[j]) { aux.pop(); j++; } } for(; j \u0026lt; popV.size();) { if(aux.top() == popV[j]) { aux.pop(); j++; } else break; } return aux.empty(); } }; 22题目描述 从上往下打印二叉树：\n本题知识点：队列，树\n从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n思路 其实比较简单的一个题，我的思路陷入到递归里面去了，，但其实不用，使用一个队列就可以简单解决问题。 用一个队列，可以按从左到右压入树的一层，这样就实现了题目所要求的目的。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;int\u0026gt; PrintFromTopToBottom(TreeNode* root) { vector\u0026lt;int\u0026gt; P; queue\u0026lt;TreeNode*\u0026gt; aux; if(root == NULL) return P; aux.push(root); while(!aux.empty()) { P.push_back(aux.front() -\u0026gt; val); if(aux.front() -\u0026gt; left != NULL) aux.push(aux.front() -\u0026gt; left); if(aux.front() -\u0026gt; right != NULL) aux.push(aux.front() -\u0026gt; right); aux.pop(); } return P; } }; 23题目描述 二叉搜索树的后序遍历序列：\n本题知识点：栈，树\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。\n思路 BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。 此时要注意要想到判断非法的条件是什么，就是后半段中有元素小于根节点。\n代码 class Solution { public: bool Verify(vector\u0026lt;int\u0026gt; sequence, int left, int right) { if(left \u0026gt;= right) return true; int new_left = left; while(new_left \u0026lt; right \u0026amp;\u0026amp; sequence[new_left] \u0026lt; sequence[right]) new_left++; for(int i = new_left + 1; i \u0026lt; right; i++) if(sequence[i] \u0026lt; sequence[right]) return false; return Verify(sequence, left, new_left - 1) \u0026amp;\u0026amp; Verify(sequence, new_left, right - 1); } bool VerifySquenceOfBST(vector\u0026lt;int\u0026gt; sequence) { if(sequence.empty()) return false; return Verify(sequence, 0, sequence.size() - 1); } }; 24题目描述 二叉树中和为某一值的路径：\n本题知识点：树\n输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)\n思路 采用递归的思路，这里主要熟悉，全局变量在递归中的应用，和STL 插入的方法。设置一个暂时数组与要存放的二维数组。采用递归一直到叶子节点，如果不符合，不要忘记在暂时数组中pop出存放的节点。有点类似于DFS的思路。注意题目要求返回的list数组长度大的在前面，所以在加入到二维数组中时要加一个判断，判断数组list的长短，长的放前面。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; paths; vector\u0026lt;int\u0026gt; temp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; FindPath(TreeNode* root,int expectNumber) { if(root == NULL || expectNumber \u0026lt; root -\u0026gt; val) return paths; temp.push_back(root -\u0026gt; val); if(root -\u0026gt; val == expectNumber \u0026amp;\u0026amp; root -\u0026gt; left == NULL \u0026amp;\u0026amp; root -\u0026gt; right == NULL) { if(paths.size() == 0) paths.push_back(temp); else { for(int i = 0; i \u0026lt; paths.size(); i++) { if(temp.size() \u0026gt; paths[i].size()) { paths.insert(paths.begin() + i, temp); break; } else if(i == paths.size() - 1) { paths.push_back(temp); } } } } FindPath(root -\u0026gt; right, expectNumber - root -\u0026gt; val); FindPath(root -\u0026gt; left, expectNumber - root -\u0026gt; val); temp.pop_back(); return paths; } }; 25题目描述 复杂链表的复制：\n本题知识点：链表\n输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）\n思路 1、复制每个节点，如：复制节点A得到A1，将A1插入节点A后面\n2、遍历链表，A1-\u0026gt;random = A-\u0026gt;random-\u0026gt;next;\n3、将链表拆分成原链表和复制后的链表\n代码 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { } }; */ class Solution { public: RandomListNode* Clone(RandomListNode* pHead) { if(pHead == NULL) return NULL; RandomListNode* head = pHead; while(head != NULL) { RandomListNode* new_node = new RandomListNode(head -\u0026gt; label); new_node -\u0026gt; next = head -\u0026gt; next; head -\u0026gt; next = new_node; head = new_node -\u0026gt; next; } head = pHead; while(head != NULL) { if(head -\u0026gt; random != NULL) head -\u0026gt; next -\u0026gt; random = head -\u0026gt; random -\u0026gt; next; head = head -\u0026gt; next; head = head -\u0026gt; next; } RandomListNode* first_head = pHead; RandomListNode* second_head; RandomListNode* new_head = pHead -\u0026gt; next; while(first_head -\u0026gt; next != NULL) { second_head = first_head -\u0026gt; next; first_head -\u0026gt; next = second_head -\u0026gt; next; first_head = second_head; } return new_head; } }; 26题目描述： 二叉搜索树与双向链表：\n本题知识点：链表、树\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。\n思路 本题要明白一个规律：二叉搜索树的中序遍历就是从小到大，换句话说，要想从小到大遍历二叉搜索树，需要使用中序遍历。 那么使用中序遍历进行递归，进行指针的变换即可。其中的一个重要细节要注意：pre指针一定要进行引用，因为pre是一个动态的，pre的改变要返回去给前一次调用，不加引用调用结束pre没有变化，一直为空。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: TreeNode* Convert(TreeNode* pRootOfTree) { if(pRootOfTree == NULL) return NULL; TreeNode* pre = NULL; Helper(pRootOfTree, pre); TreeNode* new_root = pRootOfTree; while(new_root -\u0026gt; left != NULL) new_root = new_root -\u0026gt; left; return new_root; } void Helper(TreeNode* cur, TreeNode*\u0026amp; pre) { if(cur == NULL) return; Helper(cur -\u0026gt; left, pre); cur -\u0026gt; left = pre; if(pre) pre -\u0026gt; right = cur; pre = cur; Helper(cur -\u0026gt; right, pre); } }; 27题目描述 字符串的排列：\n本题知识点：字符串 动态规划 递归\n输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。\n输入描述： 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。\n思路 思路：递归法，问题转换为先固定第一个字符，求剩余字符的排列；求剩余字符排列时跟原问题一样。\n(1) 遍历出所有可能出现在第一个位置的字符（即：依次将第一个字符同后面所有字符交换）；\n(2) 固定第一个字符，求后面字符的排列（即：在第1步的遍历过程中，插入递归进行实现）。 需要注意的几点：\na. 先确定递归结束的条件，例如本题中可设begin == str.size() - 1;\nb. 形如 aba 或 aa 等特殊测试用例的情况，vector在进行push_back时是不考虑重复情况的，需要自行控制；\nc. 输出的排列可能不是按字典顺序排列的，可能导致无法完全通过测试用例，考虑输出前排序，或者递归之后取消复位操作。\n此题要注意的点：\n1.关于vector的进一步熟练使用，如find() sort()函数的使用 2.要想明白递归结束的条件，这是前提 3.特殊测试用例aba,aa等 用比较简单的find函数就能实现，这还是表明了要多掌握直接可用的函数。\n代码 class Solution { public: vector\u0026lt;string\u0026gt; Permutation(string str) { vector\u0026lt;string\u0026gt; print_list; if(str.empty()) return print_list; Permulation(str, print_list, 0); sort(print_list.begin(), print_list.end()); return print_list; } void Permulation(string str, vector\u0026lt;string\u0026gt; \u0026amp;print_list, int begin) { if(begin == str.size() - 1) { if(find(print_list.begin(), print_list.end(), str) == print_list.end()) print_list.push_back(str); } else { for(int i = begin; i \u0026lt; str.size(); i++) { swap(str[begin], str[i]); Permulation(str, print_list, begin + 1); swap(str[begin], str[i]); } } } void swap(char \u0026amp;a, char \u0026amp;b) { char temp = a; a = b; b = temp; } }; 28题目描述 数组中出现次数超过一半的数字\n本题知识点：数组\n数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。\n思路 思路1：\n我想的思路属于最naive的那种，，建立一个容量为10的数组，每个元素代表0-9出现的次数，遍历目标数组，出现一次则代表元素+1， 最后看哪个次数超过目标数组size/2。\n思路2：\n数组排序后，如果符合条件的数存在则一定是数组中间那个数。时间复杂度为O(NlogN)。\n思路3(我觉的不错的一个思路)：\n如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。\n代码 class Solution { public: int MoreThanHalfNum_Solution(vector\u0026lt;int\u0026gt; numbers) { vector\u0026lt;int\u0026gt; count(10); for(int i = 0; i \u0026lt; 10; i++) count[i] = 0; int print = 0; if(numbers.empty()) return print; for(int i = 0; i \u0026lt; numbers.size(); i++) count[numbers[i]]++; for(int i = 0; i \u0026lt; count.size(); i++) if(count[i] \u0026gt; (numbers.size() / 2)) print = i; return print; } }; 29题目描述 最小的K个数\n本题知识点：数组 高级算法\n输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。\n思路 本题我还是采用辅助数组，记录从0-10 是否出现过，然后从小到大把出现过的赋予到返回数组中。 本题一开始一直ac不了，后来才发现是因为没有考虑特殊情况。也就是k大于原始数组长度或者k大于10。所以还是一定要考虑周全特殊情况。\n代码 class Solution { public: vector\u0026lt;int\u0026gt; GetLeastNumbers_Solution(vector\u0026lt;int\u0026gt; input, int k) { vector\u0026lt;int\u0026gt; count(10); for(int i = 0; i \u0026lt; 10; i++) count[i] = 0; vector\u0026lt;int\u0026gt; min_numbers; if(input.empty() || k \u0026gt; input.size() || k \u0026gt; 10) return min_numbers; for(int i = 0; i \u0026lt; input.size(); i++) if(count[input[i]] == 0) count[input[i]] = 1; for(int i = 0, num = 0; i \u0026lt; 10 \u0026amp;\u0026amp; num \u0026lt; k; i++) { if(count[i]) { min_numbers.push_back(i); num++; } } return min_numbers; } }; 30题目描述 连续子数组的最大和\n本题知识点：数组\nHZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)\n思路 设置两个变量，分别存储当前最大和以及目前的和。进行循环，计算和，如果比最大和大则存储，如果小于0则置0；\n代码 class Solution { public: int FindGreatestSumOfSubArray(vector\u0026lt;int\u0026gt; array) { int tempsum = 0; int result = array[0]; if(array.empty()) return 0; for(int i = 0; i \u0026lt; array.size(); i++) { tempsum = tempsum + array[i]; if(tempsum \u0026gt; 0) { if(tempsum \u0026gt; result) result = tempsum; } if(tempsum \u0026lt;= 0) { if(tempsum \u0026gt; result) result = tempsum; tempsum = 0; } } return result; } }; ","permalink":"https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer21-30/","summary":"\u003cp\u003e剑指offer21-30题\u003c/p\u003e","title":"剑指offer21-30"},{"content":"剑指offer11-20题\n11题目描述 二进制中1的个数：\n输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n思路 首先要明白几个常识 1.计算机中整数都是以补码存储，所以此题不需考虑正负问题 2.按位与操作\u0026amp;要熟悉。\n题解思路：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100\u0026amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。\n代码 class Solution { public: int NumberOf1(int n) { int count = 0; while(n != 0) { count++; n = n \u0026amp; (n - 1); } return count; } }; 12题目描述 数值的整数次方：\n给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n保证base和exponent不同时为0\n思路 本题看题解 如果不用pow函数则需要充分考虑base exponent的各种极端情况， 我使用了pow函数，直接ac了。。\n代码 class Solution { public: double Power(double base, int exponent) { //if(base == 0) return 0.0; //if(exponent == 0) return 1.0; return pow(base, exponent); } }; 13题目描述 调整数组顺序使奇数位于偶数前面：\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n思路1 采用最暴力的方法，类似冒泡排序，两个循环，相邻两个数进行对比，如果前面为偶数后面为奇数 则两者互换。\n代码 class Solution { public: void reOrderArray(vector\u0026lt;int\u0026gt; \u0026amp;array) { for(int i = 0; i \u0026lt; array.size(); i++) { for(int j = 0; j \u0026lt; array.size(); j++) { if(((array[j] % 2) == 0) \u0026amp;\u0026amp; (array[j + 1] % 2) == 1) { int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } else continue; } } } }; 思路2 再创建一个数组，遇见偶数就存入，同时在原数组中删除，最后再存入原数组中。这里主要熟悉vector迭代器的使用。\n代码 class Solution{ public: void reOrderArray(vector\u0026lt;int\u0026gt; \u0026amp;array) { vector\u0026lt;int\u0026gt; array_temp; vector\u0026lt;int\u0026gt;::iterator ib1, ie1; ib1 = array.begin(); for (; ib1 != array.end();){ //遇见偶数，就保存到新数组，同时从原数组中删除 if (*ib1 % 2 == 0) { array_temp.push_back(*ib1); ib1 = array.erase(ib1); } else{ ib1++; } } vector\u0026lt;int\u0026gt;::iterator ib2, ie2; ib2 = array_temp.begin(); ie2 = array_temp.end(); for (; ib2 != ie2; ib2++) //将新数组的数添加到老数组 { array.push_back(*ib2); } } }; 14题目描述 链表中倒数第k个结点：\n输入一个链表，输出该链表中倒数第k个结点。\n思路 首先计算出链表长度，新建一个指针指向表头，然后向后遍历到length - k的结点就可以。思路比较简单，此题主要是特殊情况的判断，对于原链表和K的判断一定要考虑全面。\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(pListHead == NULL || k \u0026lt;= 0) return NULL; int length = 0; ListNode* pre = pListHead; while(pListHead != NULL) { pListHead = pListHead -\u0026gt; next; length++; } if(k \u0026gt; length) return NULL; for(int i = 0; i \u0026lt; length - k; i++) { pre = pre -\u0026gt; next; } return pre; } }; 15题目描述 反转链表：\n输入一个链表，反转链表后，输出新链表的表头。\n思路 很普通的反转链表，卡了好长时间，才发现是判断的==没补全。。。。还是要注意一些细节\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { if(pHead == NULL) return pHead; ListNode* now = pHead; ListNode* pre = NULL; ListNode* next = NULL; while(now != NULL) { next = now -\u0026gt; next; now -\u0026gt; next = pre; pre = now; now = next; } return pre; } }; 16题目描述 合并两个排序的链表：\n输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n思路 本题最好不要在原始链表上进行操作而是新建一个链表，两两比较，小的加入到新链表末尾，这是最方便的做法。 还有第二种思路是递归，不太容易想到，明白即可。\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { //if(pHead1 == NULL \u0026amp;\u0026amp; pHead2 == NULL) return NULL; //if(pHead1 == NULL \u0026amp;\u0026amp; pHead2 != NULL) return pHead2; //if(pHead1 != NULL \u0026amp;\u0026amp; pHead2 == NULL) return pHead1; ListNode* new_head = new ListNode(1); ListNode* head = new_head; ListNode* cur = new_head; while(pHead1 != NULL \u0026amp;\u0026amp; pHead2 != NULL) { if(pHead1 -\u0026gt; val \u0026lt;= pHead2 -\u0026gt; val) { cur -\u0026gt; next = pHead1; cur = cur -\u0026gt; next; pHead1 = pHead1 -\u0026gt; next; } else { cur -\u0026gt; next = pHead2; cur = cur -\u0026gt; next; pHead2 = pHead2 -\u0026gt; next; } } if(pHead1 != NULL) cur -\u0026gt; next = pHead1; if(pHead2 != NULL) cur -\u0026gt; next = pHead2; return head -\u0026gt; next; } }; 17题目描述 树的子结构：\n输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n思路 明显使用递归，这里需要使用两个递归来完成此任务，一个递归负责向下递推树1，第二个递归负责判断从此开始的树1子树与树2是否相同。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { if(pRoot1 == NULL || pRoot2 == NULL) return false; if(pRoot1 -\u0026gt; val == pRoot2 -\u0026gt; val) { if(IsSubtree(pRoot1, pRoot2)) return true; } return HasSubtree(pRoot1 -\u0026gt; left, pRoot2) || HasSubtree(pRoot1 -\u0026gt; right, pRoot2); } bool IsSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { if(pRoot2 == NULL) return true; if(pRoot1 == NULL) return false; if(pRoot1 -\u0026gt; val != pRoot2 -\u0026gt; val) return false; return (IsSubtree(pRoot1 -\u0026gt; left, pRoot2 -\u0026gt; left) \u0026amp;\u0026amp; IsSubtree(pRoot1 -\u0026gt; right, pRoot2 -\u0026gt; right)); } }; 18题目描述 二叉树的镜像：\n操作给定的二叉树，将其变换为源二叉树的镜像。\n思路 采用递归，这里为了避免太多判断，重点在于进行递归出口的判断(为空)，然后进行递归即可。\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void Mirror(TreeNode *pRoot) { if(pRoot == NULL) return; if(pRoot -\u0026gt; left == NULL \u0026amp;\u0026amp; pRoot -\u0026gt; right == NULL) return; TreeNode* temp = NULL; temp = pRoot -\u0026gt; left; pRoot -\u0026gt; left = pRoot -\u0026gt; right; pRoot -\u0026gt; right = temp; Mirror(pRoot -\u0026gt; left); Mirror(pRoot -\u0026gt; right); } }; 19题目描述 顺时针打印矩阵：\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.\n思路 这个题说实话还挺难的，用自己的思路没做出来，采用了一个最清晰易懂的思路：首先模拟矩阵，找规律，发现设置好四个变量后每一圈对于一个方向都是相同的。设置4个变量，分别代表目前的上下左右情况，遍历完一圈后算作一次loop，上下左右都往内部缩一圈。这其中比较难想到的是特殊情况：矩阵为单独一列或者单独一行，要想让此case通过必须在第三四个循环上加上判断。\n代码 class Solution { public: vector\u0026lt;int\u0026gt; printMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; matrix) { vector\u0026lt;int\u0026gt; printM; if(matrix.empty() || matrix[0].empty()) return printM; int rows = matrix.size(); int colomns = matrix[0].size(); int top = 0, left = 0, bottom = rows - 1, right = colomns - 1; while(top \u0026lt;= bottom \u0026amp;\u0026amp; left \u0026lt;= right) { for(int i = left; i \u0026lt;= right; i++) printM.push_back(matrix[top][i]); for(int i = top + 1; i \u0026lt;= bottom; i++) printM.push_back(matrix[i][right]); if(top \u0026lt; bottom) { for(int i = right - 1; i \u0026gt;= left; i--) printM.push_back(matrix[bottom][i]); } if(left \u0026lt; right) { for(int i = bottom - 1; i \u0026gt; top; i--) printM.push_back(matrix[i][left]); } top++, left++, bottom--, right--; } return printM; } }; 20题目描述 包含min函数的栈：\n定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。\n思路 使用两个栈，一个存放模拟真实的栈，第二个栈用来存放最小数，当新压入的数小于等于最小时压入第二个栈，此时要注意pop时，如果pop的是最小数，同样要在第二个栈中pop出。\n代码 class Solution { public: stack\u0026lt;int\u0026gt; s; stack\u0026lt;int\u0026gt; min_s; void push(int value) { s.push(value); if(min_s.empty()) min_s.push(value); if(!min_s.empty()) if(value \u0026lt;= min_s.top()) min_s.push(value); } void pop() { if(s.top() == min_s.top()) { s.pop(); min_s.pop(); } else s.pop(); } int top() { return s.top(); } int min() { return min_s.top(); } }; ","permalink":"https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer11-20/","summary":"\u003cp\u003e剑指offer11-20题\u003c/p\u003e","title":"剑指offer11-20"},{"content":"剑指offer1-10题\n01题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路 注意这个数组的特点，从左到右递增，从上到下递增，我的思路是利用这个特点进行最简单的遍历查找。\n一行一行进行比较，首先从第一行开始，判断行的首元素与target大小，如果首元素大，直接判定数组不包涵此target，如果相等返回true，如果首元素小，从行末往前进行遍历，判断target与每个元素大小，如果元素大，继续向前比，如果元素小，跳出循环进行下一行的比较\n**注意！！**编好之后一直堆栈溢出，才发现是没有判断数组是否为空，这点以后一定要注意。\n代码 class Solution { public: bool Find(int target, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; array) { if (array.empty())return false; for(int i=0;i \u0026lt; array.size(); i++) { if(array[i].empty())continue; if(array[i][0] \u0026gt; target) return false; else if(target == array[i][0]) return true; else if(target \u0026gt; array[i][0]) { for(int j=(array[i].size() - 1);j\u0026gt;0;j--) { if(target == array[i][j]) return true; else if(target \u0026lt; array[i][j]) continue; else if(target \u0026gt; array[i][j]) break; } } } return false; } }; 02题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路 这里注意一个重点是将一个字符替换成3个字符，所以不能简单搜索并替换，要考虑多加进去的两个字符，所以简单思路为明白了每一个空格就会多两个字符这个关键信息，首先统计空格个数，再算出来更改后字符串长度，再从后向前复制原始字符串内容到新字符串中，与此同时替换掉空格。\n代码 class Solution { public: void replaceSpace(char *str,int length) { int i = 0; int numSpace = 0; int newLen = 0; while(str[i] != '\\0') { if(str[i] == ' ') { numSpace++; } i++; } newLen = i + numSpace * 2; for(int j = i; j \u0026gt;= 0, newLen \u0026gt;= 0;) { if(str[j] == ' ') { str[newLen--] = '0'; str[newLen--] = '2'; str[newLen--] = '%'; j--; } else { str[newLen--] = str[j--]; } } } }; 03题目描述 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 思路1 这一题主要熟悉一下链表的操作及栈操作。第一个思路：从头到尾遍历链表，压入栈 然后从栈中弹出送入vector中。 第二个思路：\n代码 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector\u0026lt;int\u0026gt; printListFromTailToHead(ListNode* head) { vector\u0026lt;int\u0026gt; value; ListNode *p = NULL; p = head; stack\u0026lt;int\u0026gt; stk; while(p != NULL) { stk.push(p -\u0026gt; val); p = p -\u0026gt; next; } while(!stk.empty()) { value.push_back(stk.top()); stk.pop(); } return value; } }; 思路2 按顺序遍历链表，将值放入array中，再用vector的翻转函数进行翻转。\n代码 class Solution { public: vector\u0026lt;int\u0026gt; printListFromTailToHead(ListNode* head) { vector\u0026lt;int\u0026gt; value; ListNode* p = NULL; p = head; while(p != NULL) { value.push_back(p -\u0026gt; val); p = p -\u0026gt; next; } reverse(value.begin(), value.end()); return value; } }; 04题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路 主要是要清楚前序遍历后序遍历的规律，采用递归的思想，找到根节点及此节点下面的左子树，右子树，送入递归。\n代码 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector\u0026lt;int\u0026gt; pre,vector\u0026lt;int\u0026gt; vin) { if(pre.size() == 0 || vin.size() == 0) return NULL; return reConstructBinaryTreeIT(pre, vin); } TreeNode* reConstructBinaryTreeIT(vector\u0026lt;int\u0026gt; pre, vector\u0026lt;int\u0026gt; vin) { if(pre.empty()) return NULL; TreeNode* root = new TreeNode(pre[0]); auto num_root = find(vin.begin(), vin.end(), pre[0]); int left_num = num_root - vin.begin(); root -\u0026gt; left = reConstructBinaryTreeIT(vector\u0026lt;int\u0026gt;(pre.begin() + 1, pre.begin() + 1 + left_num), vector\u0026lt;int\u0026gt;(vin.begin(), vin.begin() + left_num)); root -\u0026gt; right = reConstructBinaryTreeIT(vector\u0026lt;int\u0026gt;(pre.begin() + 1 + left_num, pre.end()), vector\u0026lt;int\u0026gt;(vin.begin() + 1 + left_num, vin.end())); return root; } }; 05题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路 两个栈实现队列，因为栈的输出与队列相反，使用一个最原始的思路就是将输入压入一个栈，输出时将一个栈输入到另一个栈，这样另一个栈出栈的输出就是队列的顺序，与此同时还需要将第一个栈的这个输出pop出来，故再将第二个栈的pop完的剩余元素再次压入第一个栈中，此为一个pop过程。\n代码 class Solution { public: void push(int node) { stack1.push(node); } int pop() { while(!stack1.empty()) { stack2.push(stack1.top()); stack1.pop(); } int pop_num = stack2.top(); stack2.pop(); while(!stack2.empty()) { stack1.push(stack2.top()); stack2.pop(); } return pop_num; } private: stack\u0026lt;int\u0026gt; stack1; stack\u0026lt;int\u0026gt; stack2; }; 06题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路 本题主要在于理解非递减序列。非递减序列: 1,2,4,5,5,5,6 递增序列:1,2,4,5,6,7 当数组旋转后，最小数就很好找了。本题还有一个就是要多考虑特殊情况。各个情况考虑周全。\n代码 class Solution { public: int minNumberInRotateArray(vector\u0026lt;int\u0026gt; rotateArray) { if(rotateArray.empty()) return 0; if(rotateArray.size() == 1) return rotateArray[0]; for(int i = 0; i \u0026lt; rotateArray.size(); i++) { if (rotateArray[i + 1] \u0026lt; rotateArray[i]) return rotateArray[i + 1]; //if rotateArray[i + 1] \u0026gt;= rotateArray[i] //continue; } return rotateArray[0]; } }; 07题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n\u0026lt;=39 思路 主要得知道斐波那契数列的规则和题目的要求 斐波那契数列：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)\n代码 class Solution { public: int Fibonacci(int n) { if(n == 0) return 0; if(n == 1 || n == 2) return 1; return Fibonacci(n - 1) + Fibonacci(n - 2); } }; 08题目描述 跳青蛙：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路 一个斐波那契数列的变种。主要考察递归\n代码 class Solution { public: int jumpFloor(int number) { if(number == 0) return 0; if(number == 1) return 1; if(number == 2) return 2; return jumpFloor(number - 1) + jumpFloor(number - 2); } }; 09题目描述 变态跳青蛙：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路 从简到难，写出前几个需要的跳法，找到规律，就是斐波那契数列的变种，用递归即可。\n代码 class Solution { public: int jumpFloorII(int number) { if(number == 1) return 1; return jumpFloorII(number - 1) + jumpFloorII(number - 1); } }; 10题目描述 矩形覆盖：我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 比如n=3时，2*3的矩形块有3种覆盖方法： 思路 还是写出前几个的覆盖数，寻找规律，可以察觉又是斐波那契数列，此时不要忘记特殊情况0的处理。\n##代码\nclass Solution { public: int rectCover(int number) { if(number == 0) return 0; if(number == 1) return 1; if(number == 2) return 2; return rectCover(number - 2) + rectCover(number - 1); } }; ","permalink":"https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer01-10/","summary":"\u003cp\u003e剑指offer1-10题\u003c/p\u003e","title":"剑指offer01-10"},{"content":"Pytorch Tensorboard的简单使用 Tensorboard作为将训练过程中各个参数进行记录并可视化输出的工具，对我们来说非常重要，掌握这个工具可以给我们带来很多便利。下面结合最近使用tensorboard的实际情况简单做一下记录。\ntorch.utils.tensorboard torch中整合了tensorboard，我们可以直接使用 想要在网页进行可视化，需要安装tensorboard：\npip install tensorboard tensorboard --logdir=*** --port=*** 一个简单的使用样例： import torch from torch.utils.tensorboard import SummaryWriter writer = SummaryWriter(logdir='./exp1/') *** *** *** writer.add_scalar('Loss', loss_value, iter) #在面板增加一个scalar记录loss变化 writer.add_image('image', train_image, iter) #在面板的一个iter添加单个图片train_image writer.add_images('images', train_images, iter) #在面板的一个iter添加一个batch 目前只用到这三个比较简单的，有几点需要注意： add_scalar中的loss_value的类型需要是float or string/blobname\nadd_image中的train_image类型需要是 (3, H, W)的tensor或者numpyarray\nadd_images中的train_images类型需要是 (N, 3, H, W)的tensor或者numpyarray\n运行时会在你指定的./exp1/文件夹下产生log文件，如果没有指定文件夹会自动生成./runs文件夹，生成文件后就可以去文件夹下执行\ntensorboard --logdir=./ --port=34567 然后去网页中输入ip后面加上端口号即可查看log 调试服务器只开放端口减一的http端口，所以如果镜像端口为25000 则port填24999 访问时也是\n后续如果用到别的 会再过来更新\n","permalink":"https://cynicsss.github.io/posts/torchtensorboard/","summary":"\u003cp\u003ePytorch Tensorboard的简单使用\n\u003cimg src=\"images/tensorboard01.png\" alt=\"preview\"\u003e\u003c/p\u003e","title":"torchTensorBoard"},{"content":"此篇文章为iccv2019中关于视频分割的一篇文章，主要针对多物体进行视频object分割，值得一读\nAGSS-VOS 论文地址：\nAGSS-VOS: Attention Guided Single-Shot Video Object Segmentation\n大多数的视频分割方法每次只能处理一个object，当一个视频序列需要分割多个object时，这种方法就会非常耗时。此篇文章作者提出一个方法，只用一次前向传播，经过模糊实例和细分实例两个模块，将多个object进行一次性分割出来，整个网络框架是端到端的。作者在论文开头放了一张实验效果图，是与RGMP(一次传播只分割一个物体的典型方法)做了对比，如下图：\n可以看到，当视频物体数量上升的时候RGMP的推理时间在不断上升，而本文的方法依旧处在一个比较快速的水平，不会因物体的数量而大幅度影响推理速度。我们下面来看一下本篇文章的网络框架：\n网络框架 整个框架，初看非常复杂，不知道从哪里入手，这主要是因为输入比较多，一旦把输入一个一个理清楚，后面的网络部分是非常简单的。此方法与RGMP一样，输入一共有三帧，预测帧，预测的前一帧以及初始帧，分别为 It, It-1, I0。同时，也加入了前一帧以及初始帧的mask。\nInstance-Agnostic Module 整个网络分为三大块，首先介绍Instance-Agnostic Module这一模块，此模块的输入有两个，一个是初试帧的image及mask的叠加，另一个是预测帧及预测前一帧mask的扭曲的叠加。这两个mask都是与instance无关的，也就是每一个instance全都混在一起取一个值，预测前一帧mask的扭曲是根据当前帧及前一帧得到的光流操作后得到的。两个image+mask经过一个孪生网络，然后concat起来，会得到一个与instance无关的，相当于是只分出前景的attention。\nInstance-Specific Module 此模块的输入是当前帧image与扭曲mask的叠加，同时若有N个object，就会有N个这样的叠加，每一个代表一个object。每一个输入都经过一个轻型Encoder，输出再与扭曲mask再concat一次，经过一个Attention Generator生成attention，如图中的(d)。通过这个模块就可以得到每一个object单独的预测。\nAttention-Guided Decoder 在这一模块中，把两个模块的输出进行点乘，就会得到每个object的最终预测了。有了最终预测之后还需要一次Normalize，这一步主要是因为预测会有重叠部分，而一个像素只能代表一个object所以需要有一个操作来进行重叠区域的处理，normalize的公式如下：\nTraining Loss Loss部分作者使用了IoU Loss：\n训练的具体细节可以去原文中看，在这里不再赘述。\nExperiments 作者在 Youtube VOS 和 DAVIS-2017 上进行了实验 效果都很好。 ","permalink":"https://cynicsss.github.io/posts/agss-vos/","summary":"\u003cp\u003e此篇文章为iccv2019中关于视频分割的一篇文章，主要针对多物体进行视频object分割，值得一读\u003c/p\u003e","title":"AGSS-VOS"},{"content":"两篇文章都是将self-attention机制应用到分割当中，扩大感受野。第二篇文章采用了更巧妙的方法来减少参数。\nDANet Dual Attention Network for Scene Segmentation\nself-attention在分割中应用的大致思想是：特征图与特征图的转置进行矩阵相乘，由于特征图有channel维度，相当于是每个像素与另外每个元素都进行点乘操作，而向量的点乘几何意义为计算两个向量的相似度，两个向量越相似，它们点乘越大。看下图，特征图转置与特征图矩阵相乘后用softmax进行归一化就得到了Attention map S。S再与特征图的转置进行矩阵相乘，这个操作把相关性信息重新分布到原始特征图上，最后再将这个信息与特征图A相加，得到最终输出，这个输出结合了整张图的相关性结果。\n整个网络的框架如下图：非常简单，特征提取-\u0026gt;attention module-\u0026gt;上采样得到分割图\n除了上面说的那一部分attention，作者还加了蓝色channel attention，在这里计算特征图与特征图转置矩阵相乘操作时，相乘的顺序调换了一下，这相当于是让channel与channel之间进行点乘操作，计算channel之间的相似性，在这里我认为每张channel map代表了不同类别，这样让类别与类别计算距离，来进行辅助。作者并没有解释为什么这么做，估计这也是论文不中的原因之一。\n实验结果在cityscapes，PASCAL Context，COCO Stuff上都达到了SOTA。\nCCNet CCNet: Criss-Cross Attention for Semantic Segmentation\n本篇文章的亮点在于用了巧妙的方法减少了参数量。在上面的DANet中，attention map计算的是所有像素与所有像素之间的相似性，空间复杂度为(HxW)x(HxW)，而本文采用了criss-cross思想，只计算每个像素与其同行同列即十字上的像素的相似性，通过进行循环(两次相同操作)，间接计算到每个像素与每个像素的相似性，将空间复杂度降为(HxW)x(H+W-1)，以图为例为下：\n整个网络的架构与DANet相同，只不过attention模块有所不同，如下图：在计算矩阵相乘时每个像素只抽取特征图中对应十字位置的像素进行点乘，计算相似度。\n经过一轮此attention计算得到的attention map如下图R1所示，对于每个元素只有十字上的相似性，而通过两轮此计算，对于每个元素就会得到整张图的相似性，如R2。\n得到此结果的原因如下图，经过一轮计算，每个像素可以得到在其十字上的相似性，对于不同列不同行(不在其十字上)的像素是没有相似性的，但是这个不同行不同列像素同样也进行了相似性计算，计算了在其十字上的相似性，那么两个十字必有相交，在第二次attention计算的时候，通过交点，相当于是间接计算了这两个不同列不同行像素之间的相似性。\n实验结果达到了SOTA水平，但没有计算全部像素的attention方法准确率高。\n","permalink":"https://cynicsss.github.io/posts/danet-ccnet/danet-ccnet/","summary":"\u003cp\u003e两篇文章都是将self-attention机制应用到分割当中，扩大感受野。第二篇文章采用了更巧妙的方法来减少参数。\u003c/p\u003e","title":"DANet-CCNet"},{"content":"简单介绍本组VisDrone2019比赛Object Detection in Images任务所采用的算法方法。\nIntroduction RRNet 本次比赛提出并采用的网络框架为——RRNet，主要思想为将单阶段anchor-free算法(CenterNet)通过再次回归变为二阶段算法，通过再回归的方式让本就较精确的bbox更加精准。下图为网络框架图：\n网络主体为CenterNet,backbone为hourglass-104，两个hourglass block的输出全部参与分类及回归，Heatmap代表中心点的激活图，Size代表中心点所对应object长宽的激活图，输出的一共4个map分别进行focal loss和l1 loss的计算。此上为CenterNet的主要部分，接下来我们继续利用其输出的特征图，送入后面的Re-Regression Module进行二次回归。Re-Regression Module内部结构如下：\n通过CenterNet生成的Heatmap以及SIzemap，我们可以直接将其转换成为bbox，得到bbox之后(我们可以将其类比为faster-rcnn中RPN网络生成的候选框)，我们将这些候选区域送入ROI Align，进行再一次回归得到偏移量，将此偏移量加到原始bbox上的到修正后的输出。Major features 除了再回归网络，我们还采用了以下一些方法让性能进一步提升：\n   method mAP     1.two-stage/multi-stage ↑2%   2.wh conv ↑0.3%   3.re-sample ↑1%   4.multiscale training/test ↑2%   5.sync training ↑1%   6.nms/soft nms ↑1%   7.KL-Loss (↑1%?)   8.warm up lr -   9.mix up -   10.ellipse gaussian -    Details 1.two-stage/multi-stage two-stage便指再回归思想，对于进行多次回归(multi-stage)我们目前还没有进行实验。这个再回归让mAP提高了2%\n2.wh conv 对于CenterNet中SIzemap的回归是单纯使用3x3卷积，我们认为这种卷积核并不能get到整个object的全部信息，从而以这种方式推理出object的长与宽是不合理的，于是我们采用1xk，kx1的卷积核分别推理object的宽和长，这样可能会获得更多有效信息。 此方法提升了0.3%的mAP。\n3.Data Augmentation 简单介绍一下数据增强方面所采用的一些方法\nre-sample 我们发现对于people，pedestrian等小目标的类准确率非常低，于是采用了将hard-sample再次采样(复制)放到图上进行训练的方式。考虑到背景信息，我们首先使用在Cityscapes数据集上训好的deeplabv3以及图像腐蚀+中值滤波在我们自己的无人机数据集上分割出道路，这样复制出的人，自行车一类就可以让他们放在道路上而不是天上或楼上。\n与此同时，由于镜头视角的缘故，在同一张图片中一个人的大小是不同的，直接复制出来填到任意一个地方也是不合理的，于是我们为了解决这个问题，首先在图中找到一个像素h(高度)最矮的一个人，同时再找三个h最高的人，建立一个人的高度h与图片像素位置H的线性关系，这样就可以根据要插入的位置，计算人应有的高度放进去也就不违和了。\nmultiscale training/test 此方法比较普遍，就不过多介绍了，基本对于任何算法(检测、分割)都可以提升最终的准确率。\nmix up 通过将同一batch中的随机两两图片间进行按一定比例线性叠加，同时loss回传也按照此比例回传。论文中表明有用，但在我们的任务上性能并没有提升。\nRandom Crop | flip | Normalization 随机裁剪为600x600，水平翻转及正则化。\n4.sync training 因为用的多卡进行训练，采用同步bn优化收敛过程。效果提升1%\n5.nms/soft nms 由于此数据集中重叠物体较多，采用普通nms会将许多TP框去掉，于是采用softnms，缓解此现象的影响。\n6. KL-Loss 由于视角问题，在同一张图片中，同一类物体的大小可能相距甚远，这会影响训练，那么如何才能减少此影响呢。我们将object的分布假设为正态分布，使用KL-Loss，拉近同类物体之间在特征图上的特征分布。这在没有使用multiscale training / test的时候有1%的提升，但当用了之后便没有效果，可能是与multiscale相冲突了。\nResults 在val上mAP为39.4%\nAcknowledgement RRNet是一个采用了再回归思想的two stage anchor-free目标检测算法，通过二阶段回归获得更加精准bbox。欢迎大家在此工作上提出新的意见建议，也希望大家可以把博客网站利用起来，积极分享有用的知识，一起加油:smile:\n","permalink":"https://cynicsss.github.io/posts/visdrone2019/","summary":"简单介绍本组VisDrone2019比赛Object Detection in Images任务所采用的算法方法。\nIntroduction RRNet 本次比赛提出并采用的网络框架为——RRNet，主要思想为将单阶段anchor-free算法(CenterNet)通过再次回归变为二阶段算法，通过再回归的方式让本就较精确的bbox更加精准。下图为网络框架图：\n网络主体为CenterNet,backbone为hourglass-104，两个hourglass block的输出全部参与分类及回归，Heatmap代表中心点的激活图，Size代表中心点所对应object长宽的激活图，输出的一共4个map分别进行focal loss和l1 loss的计算。此上为CenterNet的主要部分，接下来我们继续利用其输出的特征图，送入后面的Re-Regression Module进行二次回归。Re-Regression Module内部结构如下：\n通过CenterNet生成的Heatmap以及SIzemap，我们可以直接将其转换成为bbox，得到bbox之后(我们可以将其类比为faster-rcnn中RPN网络生成的候选框)，我们将这些候选区域送入ROI Align，进行再一次回归得到偏移量，将此偏移量加到原始bbox上的到修正后的输出。Major features 除了再回归网络，我们还采用了以下一些方法让性能进一步提升：\n   method mAP     1.two-stage/multi-stage ↑2%   2.wh conv ↑0.3%   3.re-sample ↑1%   4.multiscale training/test ↑2%   5.sync training ↑1%   6.nms/soft nms ↑1%   7.KL-Loss (↑1%?)   8.warm up lr -   9.mix up -   10.ellipse gaussian -    Details 1.","title":"VisDrone2019竞赛记录"},{"content":"本文提出了上下文编码模块(Context Encoding Module)引入全局上下文信息(global contextual information)，用于捕获场景的上下文语义并选择性的突出与类别相关的特征图。 实验证明上下文编码模块能够显著的提升语义分割性能，在Pascal-Context上达到了51.7%mIoU, 在 PASCAL VOC 2012上达到了85.9% mIoU，单模型在ADE20K测试集上达到了0.5567。 此外,论文进一步讨论上下文编码模块在相对浅层的网络中提升特征表示的能力，在CIFAR-10数据集上基于14层的网络达到了3.45%的错误率，和比这个多10倍的层的网络有相当的表现。\nEncNet introduction 扩张卷积存在的问题 先进的语义分割系统通常是基于FCN架构，采用的深度卷积神经网络受益于从不同图片中学习到的丰富的对象类别信息和场景语义。CNN通过堆叠带非线性激活和下采样的卷积层能够捕获带全局接受野的信息表示，为了克服下采样带来的空间分辨率损失，最近的工作使用扩张卷积策略从预训练模型上产生密集预测。然而，此策略依然会将像素从全局场景上下文相隔开，这会导致像素错误分类。\n如下图，错误的将窗格分为门。\n金字塔结构存在的问题 近期的工作使用基于金字塔多分辨率表示扩大接受野。例如，PSPNet采用的PSP模块将特征图池化为不同尺寸，再做联接上采样；DeepLab采用ASPP模块并行的使用大扩张率卷积扩大接受野。这些方法都有提升，但是这对上下文表示都不够明确，这出现了一个问题： 捕获上下文信息是否等同于增加接受野大小？\n考虑到如下情况，在一个大型数据集上，如下图：\n如果能够先捕获到图像上下文信息(例如这是卧室)，然后，这可以提供许多相关小型目标的信息(例如卧室里面有床、椅子等)。这可以动态的减少搜索区域可能。说白了，这就是加入一个场景的先验知识进去，这样对图片中像素分类更有目的性。依照这个思路，可以设计一种方法，充分利用场景上下文和存在类别概率的之间的强相关性，这样语义分割会就容易很多。 能否利用经典方法的上下文编码结合深度学习？ 最近有工作在CNN框架中推广传统编码器方法获得了极大的进步，在本文中，使用扩展编码层来捕获全局特征的统计信息用于理解上下文语义。\ncontribution 第一个贡献： 引入了上下文编码模块，该单元用于捕获全局场景上下文信息和选择性的突出与类别相关的特征图。 集成了语义编码损失(Semantic Encoding Loss,SE-loss)。 举例来讲，不考虑车辆出现在卧室的可能性，在现有标准的训练过程使用的是像素分割损失，这不强调场景的全局信息。引入语义编码损失(SE-loss)可进一步规范网络训练，让网络预测能够预测场景中对象类别的存在，强化网络学习上下文语义。 与逐像素的损失不同，SE-Loss对于大小不同的物体有相同的贡献，在实践中这能够改善识别小物体的表现。\n第二个贡献： 设计了一个新的语义分割架构Context Encoding Network (EncNet)。如下图所示，EncNet通过上下文编码模块增强了预训练的ResNet：\nContext Encoding： 对于预训练网络，使用编码层捕获特征图的统计信息作为全局上下文语义，将编码层的输出作为编码语义(encoded semantics)，为了使用上下文，预测了一组放缩因子(scaling factors)用于突出和类别相关的特征图。编码层学习带有上下文语义的固有字典，输出丰富上下文信息的残差编码。\nInput feature: CXWXH —\u0026gt;x={x1,x2,\u0026hellip;,xN},N=H×W\nInherent codebook: D={d1,d2,\u0026hellip;,dk}\nScaling factors: S={s1,s2,\u0026hellip;,sk}\n最后会输出k个残差编码，这样做的目的是什么呢？\n通过将图像的HXW个C维特征，每一个都与语义词dk做差，然后和所有语义词做差的结果相加进行归一化，获得一个像素位置相对于某个语义词的信息eik，然后将这N个结果求和加在一块获得最终的ek，获得整张图像相对于第k个语义词的信息。\nek是C维的，最后将k个ek融合到一起，这里没有用concat，一方面concat包含了顺序信息，另一方面用加的方法节省了显存。这里加起来的含义是获得整张图像相对于K个语义词的全部信息 ，最后的e也是c维的。\nFeaturemap Attention： 为了使用编码层捕获的编码语义，预测一组特征图的放缩因子作为循环用于突出需要强调的类别。这样的方法受SE-Net等工作的启发，即考虑强调天空出现飞机，不强调出现车辆的可能性。\nSemantic Encoding Loss： 使用Semantic Encoding Loss (SE-loss)在添加少量额外计算消耗的情况下强制网络理解全局语义信息。不同于逐像素损失，SE loss 对于大小不同的目标有相同的贡献，这能够提升小目标的检测性能。\n实验结果 Results on PASCAL-Context： Results on ADE20K： Image Classification Results on CIFAR10： ","permalink":"https://cynicsss.github.io/posts/encnet/","summary":"本文提出了上下文编码模块(Context Encoding Module)引入全局上下文信息(global contextual information)，用于捕获场景的上下文语义并选择性的突出与类别相关的特征图。 实验证明上下文编码模块能够显著的提升语义分割性能，在Pascal-Context上达到了51.7%mIoU, 在 PASCAL VOC 2012上达到了85.9% mIoU，单模型在ADE20K测试集上达到了0.5567。 此外,论文进一步讨论上下文编码模块在相对浅层的网络中提升特征表示的能力，在CIFAR-10数据集上基于14层的网络达到了3.45%的错误率，和比这个多10倍的层的网络有相当的表现。\nEncNet introduction 扩张卷积存在的问题 先进的语义分割系统通常是基于FCN架构，采用的深度卷积神经网络受益于从不同图片中学习到的丰富的对象类别信息和场景语义。CNN通过堆叠带非线性激活和下采样的卷积层能够捕获带全局接受野的信息表示，为了克服下采样带来的空间分辨率损失，最近的工作使用扩张卷积策略从预训练模型上产生密集预测。然而，此策略依然会将像素从全局场景上下文相隔开，这会导致像素错误分类。\n如下图，错误的将窗格分为门。\n金字塔结构存在的问题 近期的工作使用基于金字塔多分辨率表示扩大接受野。例如，PSPNet采用的PSP模块将特征图池化为不同尺寸，再做联接上采样；DeepLab采用ASPP模块并行的使用大扩张率卷积扩大接受野。这些方法都有提升，但是这对上下文表示都不够明确，这出现了一个问题： 捕获上下文信息是否等同于增加接受野大小？\n考虑到如下情况，在一个大型数据集上，如下图：\n如果能够先捕获到图像上下文信息(例如这是卧室)，然后，这可以提供许多相关小型目标的信息(例如卧室里面有床、椅子等)。这可以动态的减少搜索区域可能。说白了，这就是加入一个场景的先验知识进去，这样对图片中像素分类更有目的性。依照这个思路，可以设计一种方法，充分利用场景上下文和存在类别概率的之间的强相关性，这样语义分割会就容易很多。 能否利用经典方法的上下文编码结合深度学习？ 最近有工作在CNN框架中推广传统编码器方法获得了极大的进步，在本文中，使用扩展编码层来捕获全局特征的统计信息用于理解上下文语义。\ncontribution 第一个贡献： 引入了上下文编码模块，该单元用于捕获全局场景上下文信息和选择性的突出与类别相关的特征图。 集成了语义编码损失(Semantic Encoding Loss,SE-loss)。 举例来讲，不考虑车辆出现在卧室的可能性，在现有标准的训练过程使用的是像素分割损失，这不强调场景的全局信息。引入语义编码损失(SE-loss)可进一步规范网络训练，让网络预测能够预测场景中对象类别的存在，强化网络学习上下文语义。 与逐像素的损失不同，SE-Loss对于大小不同的物体有相同的贡献，在实践中这能够改善识别小物体的表现。\n第二个贡献： 设计了一个新的语义分割架构Context Encoding Network (EncNet)。如下图所示，EncNet通过上下文编码模块增强了预训练的ResNet：\nContext Encoding： 对于预训练网络，使用编码层捕获特征图的统计信息作为全局上下文语义，将编码层的输出作为编码语义(encoded semantics)，为了使用上下文，预测了一组放缩因子(scaling factors)用于突出和类别相关的特征图。编码层学习带有上下文语义的固有字典，输出丰富上下文信息的残差编码。\nInput feature: CXWXH —\u0026gt;x={x1,x2,\u0026hellip;,xN},N=H×W\nInherent codebook: D={d1,d2,\u0026hellip;,dk}\nScaling factors: S={s1,s2,\u0026hellip;,sk}\n最后会输出k个残差编码，这样做的目的是什么呢？\n通过将图像的HXW个C维特征，每一个都与语义词dk做差，然后和所有语义词做差的结果相加进行归一化，获得一个像素位置相对于某个语义词的信息eik，然后将这N个结果求和加在一块获得最终的ek，获得整张图像相对于第k个语义词的信息。\nek是C维的，最后将k个ek融合到一起，这里没有用concat，一方面concat包含了顺序信息，另一方面用加的方法节省了显存。这里加起来的含义是获得整张图像相对于K个语义词的全部信息 ，最后的e也是c维的。\nFeaturemap Attention： 为了使用编码层捕获的编码语义，预测一组特征图的放缩因子作为循环用于突出需要强调的类别。这样的方法受SE-Net等工作的启发，即考虑强调天空出现飞机，不强调出现车辆的可能性。\nSemantic Encoding Loss： 使用Semantic Encoding Loss (SE-loss)在添加少量额外计算消耗的情况下强制网络理解全局语义信息。不同于逐像素损失，SE loss 对于大小不同的目标有相同的贡献，这能够提升小目标的检测性能。\n实验结果 Results on PASCAL-Context： Results on ADE20K： Image Classification Results on CIFAR10： ","title":"EncNet"},{"content":"","permalink":"https://cynicsss.github.io/l2/archives/","summary":"archives","title":"Archive"},{"content":"","permalink":"https://cynicsss.github.io/archives/","summary":"archives","title":"Archive"},{"content":"","permalink":"https://cynicsss.github.io/search/","summary":"","title":"Search"},{"content":"","permalink":"https://cynicsss.github.io/search.l2/","summary":"","title":"SearchL2"}]