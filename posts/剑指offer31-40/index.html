<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>剑指offer31-40 | Cynicsss</title>

<meta name="keywords" content="" />
<meta name="description" content="剑指题目">
<meta name="author" content="Cynicsss">
<link rel="canonical" href="https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer31-40/" />
<link href="https://cynicsss.github.io/assets/css/stylesheet.min.a6f0d5df794729458ca1bb78b2bf3b208731513d810461a864ce51071e20ea48.css" integrity="sha256-pvDV33lHKUWMobt4sr87IIcxUT2BBGGoZM5RBx4g6kg=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://cynicsss.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cynicsss.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cynicsss.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cynicsss.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://cynicsss.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.79.1" />


<meta property="og:title" content="剑指offer31-40" />
<meta property="og:description" content="剑指题目" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer31-40/" />
<meta property="article:published_time" content="2020-04-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-04-05T00:00:00+00:00" /><meta property="og:site_name" content="Cynicsss" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="剑指offer31-40"/>
<meta name="twitter:description" content="剑指题目"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "剑指offer31-40",
  "name": "剑指offer31-40",
  "description": "剑指offer31-40题\n",
  "keywords": [
    
  ],
  "articleBody": "剑指offer31-40题\n31题目描述 整数中1出现的次数（从1到n整数中1出现的次数）\n求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。\n思路 注意审题，1出现的次数，不是包含1的数有多少个。 问题不要想复杂了，使用简单的模10即可解决。\n代码 class Solution { public: int NumberOf1Between1AndN_Solution(int n) { int num = 0; if(n 32题目描述 把数组排成最小的数：\n输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。\n思路 用vector自带sort函数进行排序，顺序由自己重新定义：a b转换成string后进行比较，abba表示后面的要放到前面。这里需要熟悉vector的sort函数以及to_string，string之间的比较。https://blog.csdn.net/ihadl/article/details/7400929\n代码 class Solution { public: static bool exchange(int i, int j) { string A = \"\"; string B = \"\"; A += to_string(i); A += to_string(j); B += to_string(j); B += to_string(i); return A numbers) { string result = \"\"; if(numbers.empty()) return result; sort(numbers.begin(), numbers.end(), exchange); for(int i = 0; i 33题目描述 丑数:\n把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n思路 链接：https://www.nowcoder.com/questionTerminal/6aa9e04fc3794f68acf8778237ba065b 来源：牛客网\n通俗易懂的解释： 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方***得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：\n（1）丑数数组： 1\n乘以2的队列：2\n乘以3的队列：3\n乘以5的队列：5\n选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（2）丑数数组：1,2\n乘以2的队列：4\n乘以3的队列：3，6\n乘以5的队列：5，10\n选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（3）丑数数组：1,2,3\n乘以2的队列：4,6\n乘以3的队列：6,9\n乘以5的队列：5,10,15\n选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（4）丑数数组：1,2,3,4\n乘以2的队列：6，8\n乘以3的队列：6,9,12\n乘以5的队列：5,10,15,20\n选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；\n（5）丑数数组：1,2,3,4,5\n乘以2的队列：6,8,10，\n乘以3的队列：6,9,12,15\n乘以5的队列：10,15,20,25\n选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；\n…………………… 疑问：\n1.为什么分三个队列？\n丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；\n2.为什么比较三个队列头部最小的数放入丑数数组？\n因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。\n实现思路：\n我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；\n（1）1\n|2\n|3\n|5\n目前指针指向0,0,0，队列头arr[0] * 2 = 2, arr[0] * 3 = 3, arr[0] * 5 = 5\n（2）1 2\n2 |4\n|3 6\n|5 10\n目前指针指向1,0,0，队列头arr[1] * 2 = 4, arr[0] * 3 = 3, arr[0] * 5 = 5\n（3）1 2 3\n2| 4 6\n3 |6 9\n|5 10 15\n目前指针指向1,1,0，队列头arr[1] * 2 = 4, arr[1] * 3 = 6, arr[0] * 5 = 5\n代码 class Solution { public: int GetUglyNumber_Solution(int index) { if (index res(index); res[0] = 1; int t2 = 0, t3 = 0, t5 = 0, i; for (i = 1; i 34题目描述 第一个只出现一次的字符\n在一个字符串(0思路1 建立两个辅助数组和一个辅助字符串。第一个辅助数组count用来记录每个字符出现的次数，第二个辅助数组address用来记录字符出现的地址，辅助字符串用来记录出现的字符。三者在位置上对应。遍历整个字符串，直接将出现的字符相应属性记录在辅助数组与字符串中即可。 最后遍历count找到第一个为1的index，其对应的address就是这个字符的位置。\n代码 class Solution { public: int FirstNotRepeatingChar(string str) { int flag = 0; vector count; vector character; vector address; for(int i = 0; i 思路2 使用STL的map(1对1关联容器)记录， 更加方便。\n代码 class Solution { public: int FirstNotRepeatingChar(string str) { mapmp; for(int i = 0; i 35题目描述 数组中的逆序数\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007\n输入描述:\n题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size示例1：\n输入 1,2,3,4,5,6,7,0 输出 7 思路 思路分析：\n看到这个题目，我们的第一反应是顺序扫描整个数组。每扫描到一个数组的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n个数字。由于每个数字都要和O(n)这个数字比较，因此这个算法的时间复杂度为O(n^2)。\n我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿ta和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。\n(a) 把长度为4的数组分解成两个长度为2的子数组；\n(b) 把长度为2的数组分解成两个成都为1的子数组；\n(c) 把长度为1的子数组 合并、排序并统计逆序对 ；\n(d) 把长度为2的子数组合并、排序，并统计逆序对；\n在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。\n接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。\n我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。\n过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。\n交换copy和data是因为：\n1.在每次的操作中，数值的比较都是采用当前传入函数中第一项，也就是data；比较的结果都存放到copy中；也就意味着此时copy中是经过此次调用的结果。\n2.从最底层返回时，进入了(start == end)的情形，data 和 copy 完全没有修改，此时copy和data还是一样的。\n3.进入倒数第二层时，程序进入上图26行以后部分，copy是部分排序后的新数组，data是旧数组。注意这里都是传值的调用，数组都是直接修改的。\n倒数第二层使用的copy其实是倒数第三层中的data,这就确保了倒数第三层进入26行以后时，数据比较使用的data是最新排序的数组。\n4.倒数第三层将排序的结果存入copy中。程序在倒数第四层进入26行后，使用的data数组为刚刚倒数第三层中的最新排序的copy.\n5.也就是说，在每次程序进入26行时，此时的data是最新的排序结果，copy是次新的结果。 在最后一次进入26行以后时，copy为完整排序后的结果，data是次新的结果。\n然而这里第一个类内函数调用第二个函数时，data和copy的顺序没有改变，所以最后结果应该copy是完整排序的结果.data是差一步完成排序的结果。以输入[7,5,6,4], 最后的结果copy[4,5,6,7], data[5,7,4,6].\n代码 class Solution { public: int InversePairs(vector data) { if(data.empty()) return 0; vector copy; for(int i = 0; i \u0026 data, vector\u0026 copy, int start, int end) { if(start == end) { copy[start] = data[start]; return 0; } int mid = (end - start) / 2; long long left = MergeSort(copy, data, start, start + mid); long long right = MergeSort(copy, data, start + mid + 1, end); int left_point = start + mid; int right_point = end; int index_copy = end; long long count = 0; while(left_point = start \u0026\u0026 right_point = start + mid + 1) { if(data[left_point]  data[right_point]) { count = count + (right_point - (start + mid + 1) + 1); copy[index_copy--] = data[left_point--]; } else { copy[index_copy--] = data[right_point--]; } } while(left_point = start) copy[index_copy--] = data[left_point--]; while(right_point = start + mid + 1) copy[index_copy--] = data[right_point--]; return count + left + right; } }; 36题目描述 两个链表的第一个公共结点\n输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）\n思路 本题首先要明白，公共结点代表着，两个链表拥有公共尾部(因为只有一个next)。 所以先计算两者长度，然后让长的先走两个链表长度差后 再一起走，当相同时，就是第一个公共结点。\n代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) { if(pHead1 == NULL || pHead2 == NULL) return NULL; int pHead1_len = 0; int pHead2_len = 0; ListNode* p1 = pHead1; ListNode* p2 = pHead2; while(p1 != NULL) { pHead1_len++; p1 = p1 - next; } while(p2 != NULL) { pHead2_len++; p2 = p2 - next; } p1 = pHead1; p2 = pHead2; int difference = 0; if(pHead1_len  pHead2_len) { difference = pHead1_len - pHead2_len; while(difference) { p1 = p1 - next; difference--; } } if(pHead2_len  pHead1_len) { difference = pHead2_len - pHead1_len; while(difference) { p2 = p2 - next; difference--; } } while(p1 != NULL) { if(p1 == p2) return p1; else { p1 = p1 - next; p2 = p2 - next; } } return NULL; } }; 37题目描述 数字在排序数组中出现的次数\n统计一个数字在排序数组中出现的次数。\n思路1 我所采用的二分查找变形。使用二分查找，找到k出现的最左位置，再向后遍历，如果重复则加一 不重复则break；\n代码 class Solution { public: int GetNumberOfK(vector data ,int k) { if(data.empty()) return 0; int lower = get_lower(data, k); int count = 0; if(lower != -1) { while(lower data, int k) { int start = 0; int end = data.size() - 1; int mid = (start + end) / 2; int lower = -1; while(start data[mid]) start = mid + 1; mid = (start + end) / 2; } return lower; } }; 思路2 由于数组有序，所以使用二分查找方法定位k的第一次出现位置和最后一次出现位置 (找到上界下界，此程序有bug，有特殊测试用例则无法通过 （还有一种情况不严谨，就是比如1，2，3，4，6，7寻找5，会返回6的下标但是此刻数组中不存在5）)\n代码 链接：https://www.nowcoder.com/questionTerminal/70610bf967994b22bb1c26f9ae901fa2 来源：牛客网 class Solution { public: int GetNumberOfK(vector data ,int k) { int lower = getLower(data,k); int upper = getUpper(data,k); return upper - lower + 1; } //获取k第一次出现的下标 int getLower(vector data,int k){ int start = 0,end = data.size()-1; int mid = (start + end)/2; while(start data,int k){ int start = 0,end = data.size()-1; int mid = (start + end)/2; while(start 38题目描述 二叉树的深度\n输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。\n思路1 使用递归，左子树深度大则返回左子树深度，反之返回右子树\n代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: int TreeDepth(TreeNode* pRoot) { if(pRoot == NULL) return 0; int depth = 0; depth = count(pRoot, depth); return depth; } int count(TreeNode* p, int depth) { depth++; int left_depth = depth; int right_depth = depth; if(p - left != NULL) left_depth = count(p - left, depth); if(p - right != NULL) right_depth = count(p - right, depth); return max(left_depth, right_depth); } }; 思路2 使用队列，进行层次遍历\n代码 class Solution { public: int TreeDepth(TreeNode* pRoot) { if (!pRoot) return 0; queue que; que.push(pRoot);int depth=0; while (!que.empty()) { int size=que.size(); depth++; for (int i=0;ileft) que.push(node-left); if (node-right) que.push(node-right); } } return depth; } }; 39题目描述 平衡二叉树\n输入一棵二叉树，判断该二叉树是否是平衡二叉树。\n思路 使用递归，这里要注意平衡二叉树的定义，一个平衡二叉树中每一个单独的子树也是一个平衡二叉树。平衡二叉树：左子树右子树深度之差不超过1。\n使用了两个递归，一个是判断当前子树左右深度是否超过1(是否是平衡二叉树)， 另一个是计算深度。 如果其中一个子树不是平衡二叉树，则直接返回否。\n代码 class Solution { public: bool IsBalanced_Solution(TreeNode* pRoot) { if(pRoot == NULL) return 1; return IsBalanced(pRoot, 1); } bool IsBalanced(TreeNode* pRoot, bool is) { if(is == false) return false; int right_depth = 0; int left_depth = 0; bool right_is = 1; bool left_is = 1; if(pRoot - left != NULL) { left_depth = CountDepth(pRoot - left, left_depth); left_is = IsBalanced(pRoot - left, 1); } if(pRoot - right != NULL) { right_depth = CountDepth(pRoot - right, right_depth); right_is = IsBalanced(pRoot - right, 1); } if(abs(right_depth - left_depth)  1) is = 0; return is \u0026\u0026 right_is \u0026\u0026 left_is; } int CountDepth(TreeNode* pRoot, int depth) { depth++; int left_depth = depth; int right_depth = depth; if(pRoot - left != NULL) left_depth = CountDepth(pRoot - left, left_depth); if(pRoot - right != NULL) right_depth = CountDepth(pRoot - right, right_depth); return max(left_depth, right_depth); } }; 40题目描述 数组中只出现一次的数字\n一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。\n思路 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。\n这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。\n有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。\n我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。\n现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。\n代码 class Solution { public: void FindNumsAppearOnce(vector data,int* num1,int *num2) { if(data.size()  1; index++; } *num1 = 0; *num2 = 0; for(int i = 0; i  index; return (i \u0026 1); } }; ",
  "wordCount" : "1511",
  "inLanguage": "en",
  "datePublished": "2020-04-05T00:00:00Z",
  "dateModified": "2020-04-05T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Cynicsss"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cynicsss.github.io/posts/%E5%89%91%E6%8C%87offer31-40/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cynicsss",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cynicsss.github.io/favicon.ico"
    }
  }
}
</script>



</head>

<body class="">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cynicsss.github.io/" accesskey="h" title="Cynicsss (Alt + H)">Cynicsss</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://cynicsss.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://cynicsss.github.io/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://cynicsss.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      剑指offer31-40
    </h1>
    <div class="post-meta">

April 5, 2020&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Cynicsss

    </div>
  </header> 

  <div class="toc">
    <details  open>
      <summary accesskey="c" title="(Alt + C)">
        <div class="details">Table of Contents</div>
      </summary>
      <blockquote><ul><li>
        <a href="#31%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="31题目描述">31题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af" aria-label="思路">思路</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81" aria-label="代码">代码</a></li><li>
        <a href="#32%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="32题目描述">32题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af-1" aria-label="思路">思路</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-1" aria-label="代码">代码</a></li><li>
        <a href="#33%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="33题目描述">33题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af-2" aria-label="思路">思路</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-2" aria-label="代码">代码</a></li><li>
        <a href="#34%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="34题目描述">34题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af1" aria-label="思路1">思路1</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-3" aria-label="代码">代码</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af2" aria-label="思路2">思路2</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-4" aria-label="代码">代码</a></li><li>
        <a href="#35%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="35题目描述">35题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af-3" aria-label="思路">思路</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-5" aria-label="代码">代码</a></li><li>
        <a href="#36%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="36题目描述">36题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af-4" aria-label="思路">思路</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-6" aria-label="代码">代码</a></li><li>
        <a href="#37%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="37题目描述">37题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af1-1" aria-label="思路1">思路1</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-7" aria-label="代码">代码</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af2-1" aria-label="思路2">思路2</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-8" aria-label="代码">代码</a></li><li>
        <a href="#38%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="38题目描述">38题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af1-2" aria-label="思路1">思路1</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-9" aria-label="代码">代码</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af2-2" aria-label="思路2">思路2</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-10" aria-label="代码">代码</a></li><li>
        <a href="#39%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="39题目描述">39题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af-5" aria-label="思路">思路</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-11" aria-label="代码">代码</a></li><li>
        <a href="#40%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" aria-label="40题目描述">40题目描述</a></li><li>
        <a href="#%e6%80%9d%e8%b7%af-6" aria-label="思路">思路</a></li><li>
        <a href="#%e4%bb%a3%e7%a0%81-12" aria-label="代码">代码</a></li></ul>
      </blockquote>
    </details>
  </div>
  <div class="post-content">
<p>剑指offer31-40题</p>
<h2 id="31题目描述">31题目描述<a hidden class="anchor" aria-hidden="true" href="#31题目描述">#</a></h2>
<p>整数中1出现的次数（从1到n整数中1出现的次数）<br>
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h2 id="思路">思路<a hidden class="anchor" aria-hidden="true" href="#思路">#</a></h2>
<p>注意审题，1出现的次数，不是包含1的数有多少个。 问题不要想复杂了，使用简单的模10即可解决。</p>
<h2 id="代码">代码<a hidden class="anchor" aria-hidden="true" href="#代码">#</a></h2>
<pre><code>class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int num = 0;  
        if(n &lt; 1) return 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int temp = i;
            while(temp)
            {
                if(temp % 10 == 1) num++;
                temp = temp / 10;
            }
        }
        return num;
    }
};
</code></pre><h2 id="32题目描述">32题目描述<a hidden class="anchor" aria-hidden="true" href="#32题目描述">#</a></h2>
<p>把数组排成最小的数：<br>
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="思路-1">思路<a hidden class="anchor" aria-hidden="true" href="#思路-1">#</a></h2>
<p>用vector自带sort函数进行排序，顺序由自己重新定义：a b转换成string后进行比较，ab&lt;ba则保持顺序不变，ab&gt;ba表示后面的要放到前面。这里需要熟悉vector的sort函数以及to_string，string之间的比较。https://blog.csdn.net/ihadl/article/details/7400929</p>
<h2 id="代码-1">代码<a hidden class="anchor" aria-hidden="true" href="#代码-1">#</a></h2>
<pre><code>class Solution {
public:
    static bool exchange(int i, int j)
    {
        string A = &quot;&quot;;
        string B = &quot;&quot;;
        A += to_string(i);
        A += to_string(j);
        B += to_string(j);
        B += to_string(i);
        return A &lt; B;
    }
    
    string PrintMinNumber(vector&lt;int&gt; numbers) 
    {
        string result = &quot;&quot;;
        if(numbers.empty()) return result;
        sort(numbers.begin(), numbers.end(), exchange);
        for(int i = 0; i &lt; numbers.size(); i++)
            result += to_string(numbers[i]);
        return result;
    }
};
</code></pre><h2 id="33题目描述">33题目描述<a hidden class="anchor" aria-hidden="true" href="#33题目描述">#</a></h2>
<p>丑数:<br>
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h2 id="思路-2">思路<a hidden class="anchor" aria-hidden="true" href="#思路-2">#</a></h2>
<p>链接：https://www.nowcoder.com/questionTerminal/6aa9e04fc3794f68acf8778237ba065b
来源：牛客网</p>
<p>通俗易懂的解释：
首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方***得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：<br>
（1）丑数数组： 1<br>
乘以2的队列：2<br>
乘以3的队列：3<br>
乘以5的队列：5<br>
选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；<br>
（2）丑数数组：1,2<br>
乘以2的队列：4<br>
乘以3的队列：3，6<br>
乘以5的队列：5，10<br>
选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；<br>
（3）丑数数组：1,2,3<br>
乘以2的队列：4,6<br>
乘以3的队列：6,9<br>
乘以5的队列：5,10,15<br>
选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；<br>
（4）丑数数组：1,2,3,4<br>
乘以2的队列：6，8<br>
乘以3的队列：6,9,12<br>
乘以5的队列：5,10,15,20<br>
选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；<br>
（5）丑数数组：1,2,3,4,5<br>
乘以2的队列：6,8,10，<br>
乘以3的队列：6,9,12,15<br>
乘以5的队列：10,15,20,25<br>
选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；<br>
……………………
疑问：<br>
1.为什么分三个队列？<br>
丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；<br>
2.为什么比较三个队列头部最小的数放入丑数数组？<br>
因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。<br>
实现思路：<br>
我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；<br>
（1）1<br>
|2<br>
|3<br>
|5<br>
目前指针指向0,0,0，队列头arr[0] * 2 = 2,  arr[0] * 3 = 3,  arr[0] * 5 = 5<br>
（2）1 2<br>
2 |4<br>
|3 6<br>
|5 10<br>
目前指针指向1,0,0，队列头arr[1] * 2 = 4,  arr[0] * 3 = 3, arr[0] * 5 = 5<br>
（3）1 2 3<br>
2| 4 6<br>
3 |6 9<br>
|5 10 15<br>
目前指针指向1,1,0，队列头arr[1] * 2 = 4,  arr[1] * 3 = 6, arr[0] * 5 = 5</p>
<h2 id="代码-2">代码<a hidden class="anchor" aria-hidden="true" href="#代码-2">#</a></h2>
<pre><code>class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        if (index &lt; 7)return index;
        vector&lt;int&gt; res(index);
        res[0] = 1;
        int t2 = 0, t3 = 0, t5 = 0, i;
        for (i = 1; i &lt; index; ++i)
        {
            res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5));
            if (res[i] == res[t2] * 2)t2++;
            if (res[i] == res[t3] * 3)t3++;
            if (res[i] == res[t5] * 5)t5++;
        }
        return res[index - 1];
    }
};

</code></pre><h2 id="34题目描述">34题目描述<a hidden class="anchor" aria-hidden="true" href="#34题目描述">#</a></h2>
<p>第一个只出现一次的字符<br>
在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p>
<h2 id="思路1">思路1<a hidden class="anchor" aria-hidden="true" href="#思路1">#</a></h2>
<p>建立两个辅助数组和一个辅助字符串。第一个辅助数组count用来记录每个字符出现的次数，第二个辅助数组address用来记录字符出现的地址，辅助字符串用来记录出现的字符。三者在位置上对应。遍历整个字符串，直接将出现的字符相应属性记录在辅助数组与字符串中即可。 最后遍历count找到第一个为1的index，其对应的address就是这个字符的位置。</p>
<h2 id="代码-3">代码<a hidden class="anchor" aria-hidden="true" href="#代码-3">#</a></h2>
<pre><code>class Solution {
public:
    int FirstNotRepeatingChar(string str) 
    {
        int flag = 0;
        vector&lt;int&gt; count;
        vector&lt;char&gt; character;
        vector&lt;int&gt; address;
        for(int i = 0; i &lt; str.length(); i++)
        {
            flag = 0;
            if(count.empty()) 
            {
                count.push_back(1);
                character.push_back(str[i]);
                address.push_back(i);
                continue;
            }
            for(int j = 0; j &lt; character.size(); j++)
            {
                if(str[i] == character[j])
                {
                    count[j]++;
                    flag = 1;
                }
            }
            if(flag) continue;
            count.push_back(1);
            character.push_back(str[i]);
            address.push_back(i);
        }

        for(int i = 0; i &lt; count.size(); i++)
        {
            if(count[i] == 1) return address[i];
        }
        return -1;
    }
};
</code></pre><h2 id="思路2">思路2<a hidden class="anchor" aria-hidden="true" href="#思路2">#</a></h2>
<p>使用STL的map(1对1关联容器)记录，  更加方便。</p>
<h2 id="代码-4">代码<a hidden class="anchor" aria-hidden="true" href="#代码-4">#</a></h2>
<pre><code>class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        map&lt;char, int&gt; mp;
        for(int i = 0; i &lt; str.size(); ++i)
            mp[str[i]]++;
        for(int i = 0; i &lt; str.size(); ++i){
            if(mp[str[i]]==1)
                return i;
        }
        return -1;
    }
};
</code></pre><h2 id="35题目描述">35题目描述<a hidden class="anchor" aria-hidden="true" href="#35题目描述">#</a></h2>
<p>数组中的逆序数<br>
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>
输入描述:</p>
<pre><code>题目保证输入的数组中没有的相同的数字

数据范围：

	对于%50的数据,size&lt;=10^4

	对于%75的数据,size&lt;=10^5

	对于%100的数据,size&lt;=2*10^5
</code></pre><p>示例1：</p>
<pre><code>输入
1,2,3,4,5,6,7,0
输出
7
</code></pre><h2 id="思路-3">思路<a hidden class="anchor" aria-hidden="true" href="#思路-3">#</a></h2>
<p>思路分析：<br>
看到这个题目，我们的第一反应是顺序扫描整个数组。每扫描到一个数组的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n个数字。由于每个数字都要和O(n)这个数字比较，因此这个算法的时间复杂度为O(n^2)。<br>
我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿ta和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。</p>
<p>(a) 把长度为4的数组分解成两个长度为2的子数组；<br>
(b) 把长度为2的数组分解成两个成都为1的子数组；<br>
(c) 把长度为1的子数组 合并、排序并统计逆序对 ；<br>
(d) 把长度为2的子数组合并、排序，并统计逆序对；<br>
在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。<br>
接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。<br>
我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。</p>
<p>过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。</p>
<p>交换copy和data是因为：<br>
1.在每次的操作中，数值的比较都是采用当前传入函数中第一项，也就是data；比较的结果都存放到copy中；也就意味着此时copy中是经过此次调用的结果。<br>
2.从最底层返回时，进入了(start == end)的情形，data 和 copy 完全没有修改，此时copy和data还是一样的。<br>
3.进入倒数第二层时，程序进入上图26行以后部分，copy是部分排序后的新数组，data是旧数组。注意这里都是传值的调用，数组都是直接修改的。<br>
倒数第二层使用的copy其实是倒数第三层中的data,这就确保了倒数第三层进入26行以后时，数据比较使用的data是最新排序的数组。<br>
4.倒数第三层将排序的结果存入copy中。程序在倒数第四层进入26行后，使用的data数组为刚刚倒数第三层中的最新排序的copy.<br>
5.也就是说，在每次程序进入26行时，此时的data是最新的排序结果，copy是次新的结果。 <br>
在最后一次进入26行以后时，copy为完整排序后的结果，data是次新的结果。<br>
然而这里第一个类内函数调用第二个函数时，data和copy的顺序没有改变，所以最后结果应该copy是完整排序的结果.data是差一步完成排序的结果。以输入[7,5,6,4], 最后的结果copy[4,5,6,7], data[5,7,4,6].</p>
<h2 id="代码-5">代码<a hidden class="anchor" aria-hidden="true" href="#代码-5">#</a></h2>
<pre><code>class Solution {
public:
    int InversePairs(vector&lt;int&gt; data) 
    {
        if(data.empty()) return 0;
        vector&lt;int&gt; copy;
        for(int i = 0; i &lt; data.size(); i++)
            copy.push_back(data[i]);
        int length = data.size();
        long long count = MergeSort(data, copy, 0, length - 1);
        return count % 1000000007;
    }
    long long MergeSort(vector&lt;int&gt;&amp; data, vector&lt;int&gt;&amp; copy, int start, int end)
    {
        if(start == end)
        {
            copy[start] = data[start];
            return 0; 
        }
        int mid = (end - start) / 2;
        long long left = MergeSort(copy, data, start, start + mid);
        long long right = MergeSort(copy, data, start + mid + 1, end);
        int left_point = start + mid;
        int right_point = end;
        int index_copy = end;
        long long count = 0;
        while(left_point &gt;= start &amp;&amp; right_point &gt;= start + mid + 1)
        {
            if(data[left_point] &gt; data[right_point])
            {
                count = count + (right_point - (start + mid + 1) + 1);
                copy[index_copy--] = data[left_point--];
            }
            else
            {
                copy[index_copy--] = data[right_point--];
            }
        }
        while(left_point &gt;= start)
            copy[index_copy--] = data[left_point--];
        while(right_point &gt;= start + mid + 1)
            copy[index_copy--] = data[right_point--];
        
        return count + left + right;
    }
};
</code></pre><h2 id="36题目描述">36题目描述<a hidden class="anchor" aria-hidden="true" href="#36题目描述">#</a></h2>
<p>两个链表的第一个公共结点<br>
输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<h2 id="思路-4">思路<a hidden class="anchor" aria-hidden="true" href="#思路-4">#</a></h2>
<p>本题首先要明白，公共结点代表着，两个链表拥有公共尾部(因为只有一个next)。 所以先计算两者长度，然后让长的先走两个链表长度差后 再一起走，当相同时，就是第一个公共结点。</p>
<h2 id="代码-6">代码<a hidden class="anchor" aria-hidden="true" href="#代码-6">#</a></h2>
<pre><code>/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) 
    {
        if(pHead1 == NULL || pHead2 == NULL) return NULL;
        int pHead1_len = 0;
        int pHead2_len = 0;
        ListNode* p1 = pHead1;
        ListNode* p2 = pHead2;
        while(p1 != NULL)
        {
            pHead1_len++;
            p1 = p1 -&gt; next;
        }
        while(p2 != NULL)
        {
            pHead2_len++;
            p2 = p2 -&gt; next;
        }
        p1 = pHead1;
        p2 = pHead2;
        int difference = 0;
        if(pHead1_len &gt; pHead2_len)
        {
            difference = pHead1_len - pHead2_len;
            while(difference)
            {
                p1 = p1 -&gt; next;
                difference--;
            }
        }
        if(pHead2_len &gt; pHead1_len)
        {
            difference = pHead2_len - pHead1_len;
            while(difference)
            {
                p2 = p2 -&gt; next;
                difference--;
            }
        }
        while(p1 != NULL)
        {
            if(p1 == p2) return p1;
            else
            {
                p1 = p1 -&gt; next;
                p2 = p2 -&gt; next;
            }
        }
        return NULL;
    }
};
</code></pre><h2 id="37题目描述">37题目描述<a hidden class="anchor" aria-hidden="true" href="#37题目描述">#</a></h2>
<p>数字在排序数组中出现的次数<br>
统计一个数字在排序数组中出现的次数。</p>
<h2 id="思路1-1">思路1<a hidden class="anchor" aria-hidden="true" href="#思路1-1">#</a></h2>
<p>我所采用的二分查找变形。使用二分查找，找到k出现的最左位置，再向后遍历，如果重复则加一 不重复则break；</p>
<h2 id="代码-7">代码<a hidden class="anchor" aria-hidden="true" href="#代码-7">#</a></h2>
<pre><code>class Solution {
public:
    int GetNumberOfK(vector&lt;int&gt; data ,int k) 
    {
        if(data.empty()) return 0;
        int lower = get_lower(data, k);
        int count = 0;
        if(lower != -1)
        {
            while(lower &lt;= data.size() - 1)
            {
                if(data[lower] == k) 
                {
                    count++;
                    lower++;
                    continue;
                }
                else break;
            }
        }
        return count;
    }
    int get_lower(vector&lt;int&gt; data, int k)
    {
        int start = 0;
        int end = data.size() - 1;
        int mid = (start + end) / 2;
        int lower = -1;
        while(start &lt;= end)
        {
            if(k == data[start]) 
            {
                lower = start;
                break;
            }
            else if(k == data[mid]) 
            {
                lower = mid;
                end = mid - 1;
            }
            else if(k &lt; data[mid]) end = mid - 1;
            else if(k &gt; data[mid]) start = mid + 1;
            mid = (start + end) / 2;
        }
        return lower;
    }
};
</code></pre><h2 id="思路2-1">思路2<a hidden class="anchor" aria-hidden="true" href="#思路2-1">#</a></h2>
<p>由于数组有序，所以使用二分查找方法定位k的第一次出现位置和最后一次出现位置 (找到上界下界，此程序有bug，有特殊测试用例则无法通过 （还有一种情况不严谨，就是比如1，2，3，4，6，7寻找5，会返回6的下标但是此刻数组中不存在5）)</p>
<h2 id="代码-8">代码<a hidden class="anchor" aria-hidden="true" href="#代码-8">#</a></h2>
<pre><code>链接：https://www.nowcoder.com/questionTerminal/70610bf967994b22bb1c26f9ae901fa2
来源：牛客网

class Solution {
public:
    int GetNumberOfK(vector&lt;int&gt; data ,int k) {
        int lower = getLower(data,k);
        int upper = getUpper(data,k);
         
        return upper - lower + 1;
    }
     
    //获取k第一次出现的下标
    int getLower(vector&lt;int&gt; data,int k){
        int start = 0,end = data.size()-1;
        int mid = (start + end)/2;
         
        while(start &lt;= end){
            if(data[mid] &lt; k){
                start = mid + 1;
            }else{
                end = mid - 1;
            }
            mid = (start + end)/2;
        }
        return start;
    }
    //获取k最后一次出现的下标
    int getUpper(vector&lt;int&gt; data,int k){
         int start = 0,end = data.size()-1;
        int mid = (start + end)/2;
         
        while(start &lt;= end){
            if(data[mid] &lt;= k){
                start = mid + 1;
            }else{
                end = mid - 1;
            }
            mid = (start + end)/2;
        }
         
        return end;
    }
};
</code></pre><h2 id="38题目描述">38题目描述<a hidden class="anchor" aria-hidden="true" href="#38题目描述">#</a></h2>
<p>二叉树的深度<br>
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="思路1-2">思路1<a hidden class="anchor" aria-hidden="true" href="#思路1-2">#</a></h2>
<p>使用递归，左子树深度大则返回左子树深度，反之返回右子树</p>
<h2 id="代码-9">代码<a hidden class="anchor" aria-hidden="true" href="#代码-9">#</a></h2>
<pre><code>/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot == NULL) return 0;
        int depth = 0;
        depth = count(pRoot, depth);
        return depth;
    }
    
    int count(TreeNode* p, int depth)
    {
        depth++;
        int left_depth = depth;
        int right_depth = depth;
        if(p -&gt; left != NULL)
            left_depth = count(p -&gt; left, depth);
        if(p -&gt; right != NULL)
            right_depth = count(p -&gt; right, depth);
        return max(left_depth, right_depth);
    }
};
</code></pre><h2 id="思路2-2">思路2<a hidden class="anchor" aria-hidden="true" href="#思路2-2">#</a></h2>
<p>使用队列，进行层次遍历</p>
<h2 id="代码-10">代码<a hidden class="anchor" aria-hidden="true" href="#代码-10">#</a></h2>
<pre><code>class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
        if (!pRoot) return 0;
        queue&lt;TreeNode*&gt; que;
        que.push(pRoot);int depth=0;
        while (!que.empty()) {
            int size=que.size();
            depth++;
            for (int i=0;i&lt;size;i++) {      //一次处理一层的数据
                TreeNode *node=que.front();
                que.pop();
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            }
        }
        return depth;
    }
};
</code></pre><h2 id="39题目描述">39题目描述<a hidden class="anchor" aria-hidden="true" href="#39题目描述">#</a></h2>
<p>平衡二叉树<br>
输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h2 id="思路-5">思路<a hidden class="anchor" aria-hidden="true" href="#思路-5">#</a></h2>
<p>使用递归，这里要注意平衡二叉树的定义，一个平衡二叉树中每一个单独的子树也是一个平衡二叉树。平衡二叉树：左子树右子树深度之差不超过1。<br>
使用了两个递归，一个是判断当前子树左右深度是否超过1(是否是平衡二叉树)， 另一个是计算深度。 如果其中一个子树不是平衡二叉树，则直接返回否。</p>
<h2 id="代码-11">代码<a hidden class="anchor" aria-hidden="true" href="#代码-11">#</a></h2>
<pre><code>class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) 
    {
        if(pRoot == NULL) return 1;
        return IsBalanced(pRoot, 1);
    }
    
    bool IsBalanced(TreeNode* pRoot, bool is)
    {
        if(is == false) return false;
        int right_depth = 0;
        int left_depth = 0;
        bool right_is = 1;
        bool left_is = 1;
        if(pRoot -&gt; left != NULL)
        {
            left_depth = CountDepth(pRoot -&gt; left, left_depth);
            left_is = IsBalanced(pRoot -&gt; left, 1);
        }
        if(pRoot -&gt; right != NULL)
        {
            right_depth = CountDepth(pRoot -&gt; right, right_depth);
            right_is = IsBalanced(pRoot -&gt; right, 1);
        }
        if(abs(right_depth - left_depth) &gt; 1) is = 0;
        return is &amp;&amp; right_is &amp;&amp; left_is;
    }
    
    int CountDepth(TreeNode* pRoot, int depth)
    {
        depth++;
        int left_depth = depth;
        int right_depth = depth;
        if(pRoot -&gt; left != NULL)
            left_depth = CountDepth(pRoot -&gt; left, left_depth);
        if(pRoot -&gt; right != NULL)
            right_depth = CountDepth(pRoot -&gt; right, right_depth);
        return max(left_depth, right_depth);
    }
};
</code></pre><h2 id="40题目描述">40题目描述<a hidden class="anchor" aria-hidden="true" href="#40题目描述">#</a></h2>
<p>数组中只出现一次的数字<br>
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="思路-6">思路<a hidden class="anchor" aria-hidden="true" href="#思路-6">#</a></h2>
<p>首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。<br>
这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。<br>
有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。<br>
我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。<br>
现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。</p>
<h2 id="代码-12">代码<a hidden class="anchor" aria-hidden="true" href="#代码-12">#</a></h2>
<pre><code>class Solution {
public:
    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) 
    {
        if(data.size() &lt; 2) return ;
        int temp = data[0];
        for(int i = 1; i &lt; data.size(); i++)
            temp ^= data[i];
        if(temp == 0) return ;
        int index = 0;
        while((temp &amp; 1) == 0)
        {
            temp = temp &gt;&gt; 1;
            index++;
        }
        *num1 = 0;
        *num2 = 0;
        for(int i = 0; i &lt; data.size(); i++)
        {
            if(IsBit(data[i], index))
                *num1 ^= data[i];
            else
                *num2 ^= data[i];
        }
    }
    
    bool IsBit(int i, int index)
    {
        i = i &gt;&gt; index;
        return (i &amp; 1);
    }
};
</code></pre>
</div>
  <footer class="post-footer">



<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 剑指offer31-40 on twitter"
        href="https://twitter.com/intent/tweet/?text=%e5%89%91%e6%8c%87offer31-40&amp;url=https%3a%2f%2fcynicsss.github.io%2fposts%2f%25E5%2589%2591%25E6%258C%2587offer31-40%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 剑指offer31-40 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcynicsss.github.io%2fposts%2f%25E5%2589%2591%25E6%258C%2587offer31-40%2f&amp;title=%e5%89%91%e6%8c%87offer31-40&amp;summary=%e5%89%91%e6%8c%87offer31-40&amp;source=https%3a%2f%2fcynicsss.github.io%2fposts%2f%25E5%2589%2591%25E6%258C%2587offer31-40%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 剑指offer31-40 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fcynicsss.github.io%2fposts%2f%25E5%2589%2591%25E6%258C%2587offer31-40%2f&title=%e5%89%91%e6%8c%87offer31-40">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 剑指offer31-40 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcynicsss.github.io%2fposts%2f%25E5%2589%2591%25E6%258C%2587offer31-40%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 剑指offer31-40 on whatsapp"
        href="https://api.whatsapp.com/send?text=%e5%89%91%e6%8c%87offer31-40%20-%20https%3a%2f%2fcynicsss.github.io%2fposts%2f%25E5%2589%2591%25E6%258C%2587offer31-40%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 剑指offer31-40 on telegram"
        href="https://telegram.me/share/url?text=%e5%89%91%e6%8c%87offer31-40&amp;url=https%3a%2f%2fcynicsss.github.io%2fposts%2f%25E5%2589%2591%25E6%258C%2587offer31-40%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://cynicsss.github.io/">Cynicsss</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<button class="top-link" id="top-link" type="button" aria-label="go to top" title="Go to Top (Alt + G)" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
        <path d="M12 6H0l6-6z" /></svg>
</button>



<script defer src="https://cynicsss.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
    mybutton.onclick = function () {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        window.location.hash = ''
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
